// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/adressbook"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/balances"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/delegates"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/invoice"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/invoices_payments"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/predicate"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/privatekeys"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/recentinvoices"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/rewardsdata"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/settings"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/swaps"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/task"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/transfers"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/undelegates"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/user"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/userstate"
	"github.com/Simplewallethq/simple-wallet-tg-bot/tg-bot/ent/validators"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdressBook       = "AdressBook"
	TypeBalances         = "Balances"
	TypeDelegates        = "Delegates"
	TypeInvoice          = "Invoice"
	TypeInvoicesPayments = "Invoices_payments"
	TypePrivateKeys      = "PrivateKeys"
	TypeRecentInvoices   = "RecentInvoices"
	TypeRewardsData      = "RewardsData"
	TypeSettings         = "Settings"
	TypeSwaps            = "Swaps"
	TypeTask             = "Task"
	TypeTransfers        = "Transfers"
	TypeUndelegates      = "Undelegates"
	TypeUser             = "User"
	TypeUserState        = "UserState"
	TypeValidators       = "Validators"
)

// AdressBookMutation represents an operation that mutates the AdressBook nodes in the graph.
type AdressBookMutation struct {
	config
	op            Op
	typ           string
	id            *int
	address       *string
	name          *string
	created_at    *time.Time
	_InUpdate     *bool
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*AdressBook, error)
	predicates    []predicate.AdressBook
}

var _ ent.Mutation = (*AdressBookMutation)(nil)

// adressbookOption allows management of the mutation configuration using functional options.
type adressbookOption func(*AdressBookMutation)

// newAdressBookMutation creates new mutation for the AdressBook entity.
func newAdressBookMutation(c config, op Op, opts ...adressbookOption) *AdressBookMutation {
	m := &AdressBookMutation{
		config:        c,
		op:            op,
		typ:           TypeAdressBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdressBookID sets the ID field of the mutation.
func withAdressBookID(id int) adressbookOption {
	return func(m *AdressBookMutation) {
		var (
			err   error
			once  sync.Once
			value *AdressBook
		)
		m.oldValue = func(ctx context.Context) (*AdressBook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdressBook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdressBook sets the old AdressBook of the mutation.
func withAdressBook(node *AdressBook) adressbookOption {
	return func(m *AdressBookMutation) {
		m.oldValue = func(context.Context) (*AdressBook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdressBookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdressBookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdressBookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdressBookMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdressBook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *AdressBookMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AdressBookMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the AdressBook entity.
// If the AdressBook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdressBookMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AdressBookMutation) ResetAddress() {
	m.address = nil
}

// SetName sets the "name" field.
func (m *AdressBookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdressBookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AdressBook entity.
// If the AdressBook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdressBookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdressBookMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdressBookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdressBookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdressBook entity.
// If the AdressBook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdressBookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdressBookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetInUpdate sets the "InUpdate" field.
func (m *AdressBookMutation) SetInUpdate(b bool) {
	m._InUpdate = &b
}

// InUpdate returns the value of the "InUpdate" field in the mutation.
func (m *AdressBookMutation) InUpdate() (r bool, exists bool) {
	v := m._InUpdate
	if v == nil {
		return
	}
	return *v, true
}

// OldInUpdate returns the old "InUpdate" field's value of the AdressBook entity.
// If the AdressBook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdressBookMutation) OldInUpdate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInUpdate: %w", err)
	}
	return oldValue.InUpdate, nil
}

// ResetInUpdate resets all changes to the "InUpdate" field.
func (m *AdressBookMutation) ResetInUpdate() {
	m._InUpdate = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AdressBookMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AdressBookMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AdressBookMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AdressBookMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AdressBookMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AdressBookMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AdressBookMutation builder.
func (m *AdressBookMutation) Where(ps ...predicate.AdressBook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdressBookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdressBookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdressBook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdressBookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdressBookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdressBook).
func (m *AdressBookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdressBookMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.address != nil {
		fields = append(fields, adressbook.FieldAddress)
	}
	if m.name != nil {
		fields = append(fields, adressbook.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, adressbook.FieldCreatedAt)
	}
	if m._InUpdate != nil {
		fields = append(fields, adressbook.FieldInUpdate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdressBookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adressbook.FieldAddress:
		return m.Address()
	case adressbook.FieldName:
		return m.Name()
	case adressbook.FieldCreatedAt:
		return m.CreatedAt()
	case adressbook.FieldInUpdate:
		return m.InUpdate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdressBookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adressbook.FieldAddress:
		return m.OldAddress(ctx)
	case adressbook.FieldName:
		return m.OldName(ctx)
	case adressbook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adressbook.FieldInUpdate:
		return m.OldInUpdate(ctx)
	}
	return nil, fmt.Errorf("unknown AdressBook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdressBookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adressbook.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case adressbook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case adressbook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adressbook.FieldInUpdate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInUpdate(v)
		return nil
	}
	return fmt.Errorf("unknown AdressBook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdressBookMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdressBookMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdressBookMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdressBook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdressBookMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdressBookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdressBookMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdressBook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdressBookMutation) ResetField(name string) error {
	switch name {
	case adressbook.FieldAddress:
		m.ResetAddress()
		return nil
	case adressbook.FieldName:
		m.ResetName()
		return nil
	case adressbook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adressbook.FieldInUpdate:
		m.ResetInUpdate()
		return nil
	}
	return fmt.Errorf("unknown AdressBook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdressBookMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, adressbook.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdressBookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adressbook.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdressBookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdressBookMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdressBookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, adressbook.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdressBookMutation) EdgeCleared(name string) bool {
	switch name {
	case adressbook.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdressBookMutation) ClearEdge(name string) error {
	switch name {
	case adressbook.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown AdressBook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdressBookMutation) ResetEdge(name string) error {
	switch name {
	case adressbook.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown AdressBook edge %s", name)
}

// BalancesMutation represents an operation that mutates the Balances nodes in the graph.
type BalancesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	balance       *float64
	addbalance    *float64
	height        *uint64
	addheight     *int64
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Balances, error)
	predicates    []predicate.Balances
}

var _ ent.Mutation = (*BalancesMutation)(nil)

// balancesOption allows management of the mutation configuration using functional options.
type balancesOption func(*BalancesMutation)

// newBalancesMutation creates new mutation for the Balances entity.
func newBalancesMutation(c config, op Op, opts ...balancesOption) *BalancesMutation {
	m := &BalancesMutation{
		config:        c,
		op:            op,
		typ:           TypeBalances,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBalancesID sets the ID field of the mutation.
func withBalancesID(id int) balancesOption {
	return func(m *BalancesMutation) {
		var (
			err   error
			once  sync.Once
			value *Balances
		)
		m.oldValue = func(ctx context.Context) (*Balances, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Balances.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBalances sets the old Balances of the mutation.
func withBalances(node *Balances) balancesOption {
	return func(m *BalancesMutation) {
		m.oldValue = func(context.Context) (*Balances, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BalancesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BalancesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BalancesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BalancesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Balances.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBalance sets the "balance" field.
func (m *BalancesMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *BalancesMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Balances entity.
// If the Balances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalancesMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *BalancesMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *BalancesMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *BalancesMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetHeight sets the "height" field.
func (m *BalancesMutation) SetHeight(u uint64) {
	m.height = &u
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *BalancesMutation) Height() (r uint64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Balances entity.
// If the Balances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BalancesMutation) OldHeight(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds u to the "height" field.
func (m *BalancesMutation) AddHeight(u int64) {
	if m.addheight != nil {
		*m.addheight += u
	} else {
		m.addheight = &u
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *BalancesMutation) AddedHeight() (r int64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *BalancesMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *BalancesMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *BalancesMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *BalancesMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *BalancesMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BalancesMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *BalancesMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the BalancesMutation builder.
func (m *BalancesMutation) Where(ps ...predicate.Balances) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BalancesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BalancesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Balances, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BalancesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BalancesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Balances).
func (m *BalancesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BalancesMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.balance != nil {
		fields = append(fields, balances.FieldBalance)
	}
	if m.height != nil {
		fields = append(fields, balances.FieldHeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BalancesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case balances.FieldBalance:
		return m.Balance()
	case balances.FieldHeight:
		return m.Height()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BalancesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case balances.FieldBalance:
		return m.OldBalance(ctx)
	case balances.FieldHeight:
		return m.OldHeight(ctx)
	}
	return nil, fmt.Errorf("unknown Balances field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalancesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case balances.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case balances.FieldHeight:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Balances field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BalancesMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, balances.FieldBalance)
	}
	if m.addheight != nil {
		fields = append(fields, balances.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BalancesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case balances.FieldBalance:
		return m.AddedBalance()
	case balances.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BalancesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case balances.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case balances.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Balances numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BalancesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BalancesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BalancesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Balances nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BalancesMutation) ResetField(name string) error {
	switch name {
	case balances.FieldBalance:
		m.ResetBalance()
		return nil
	case balances.FieldHeight:
		m.ResetHeight()
		return nil
	}
	return fmt.Errorf("unknown Balances field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BalancesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, balances.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BalancesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case balances.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BalancesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BalancesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BalancesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, balances.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BalancesMutation) EdgeCleared(name string) bool {
	switch name {
	case balances.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BalancesMutation) ClearEdge(name string) error {
	switch name {
	case balances.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Balances unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BalancesMutation) ResetEdge(name string) error {
	switch name {
	case balances.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Balances edge %s", name)
}

// DelegatesMutation represents an operation that mutates the Delegates nodes in the graph.
type DelegatesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	delegator     *string
	validator     *string
	name          *string
	user_balance  *string
	amount        *string
	created_at    *time.Time
	status        *string
	_Deploy       *string
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Delegates, error)
	predicates    []predicate.Delegates
}

var _ ent.Mutation = (*DelegatesMutation)(nil)

// delegatesOption allows management of the mutation configuration using functional options.
type delegatesOption func(*DelegatesMutation)

// newDelegatesMutation creates new mutation for the Delegates entity.
func newDelegatesMutation(c config, op Op, opts ...delegatesOption) *DelegatesMutation {
	m := &DelegatesMutation{
		config:        c,
		op:            op,
		typ:           TypeDelegates,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDelegatesID sets the ID field of the mutation.
func withDelegatesID(id int) delegatesOption {
	return func(m *DelegatesMutation) {
		var (
			err   error
			once  sync.Once
			value *Delegates
		)
		m.oldValue = func(ctx context.Context) (*Delegates, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Delegates.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDelegates sets the old Delegates of the mutation.
func withDelegates(node *Delegates) delegatesOption {
	return func(m *DelegatesMutation) {
		m.oldValue = func(context.Context) (*Delegates, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DelegatesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DelegatesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DelegatesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DelegatesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Delegates.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDelegator sets the "delegator" field.
func (m *DelegatesMutation) SetDelegator(s string) {
	m.delegator = &s
}

// Delegator returns the value of the "delegator" field in the mutation.
func (m *DelegatesMutation) Delegator() (r string, exists bool) {
	v := m.delegator
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegator returns the old "delegator" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldDelegator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegator: %w", err)
	}
	return oldValue.Delegator, nil
}

// ResetDelegator resets all changes to the "delegator" field.
func (m *DelegatesMutation) ResetDelegator() {
	m.delegator = nil
}

// SetValidator sets the "validator" field.
func (m *DelegatesMutation) SetValidator(s string) {
	m.validator = &s
}

// Validator returns the value of the "validator" field in the mutation.
func (m *DelegatesMutation) Validator() (r string, exists bool) {
	v := m.validator
	if v == nil {
		return
	}
	return *v, true
}

// OldValidator returns the old "validator" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldValidator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidator: %w", err)
	}
	return oldValue.Validator, nil
}

// ClearValidator clears the value of the "validator" field.
func (m *DelegatesMutation) ClearValidator() {
	m.validator = nil
	m.clearedFields[delegates.FieldValidator] = struct{}{}
}

// ValidatorCleared returns if the "validator" field was cleared in this mutation.
func (m *DelegatesMutation) ValidatorCleared() bool {
	_, ok := m.clearedFields[delegates.FieldValidator]
	return ok
}

// ResetValidator resets all changes to the "validator" field.
func (m *DelegatesMutation) ResetValidator() {
	m.validator = nil
	delete(m.clearedFields, delegates.FieldValidator)
}

// SetName sets the "name" field.
func (m *DelegatesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DelegatesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DelegatesMutation) ClearName() {
	m.name = nil
	m.clearedFields[delegates.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DelegatesMutation) NameCleared() bool {
	_, ok := m.clearedFields[delegates.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DelegatesMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, delegates.FieldName)
}

// SetUserBalance sets the "user_balance" field.
func (m *DelegatesMutation) SetUserBalance(s string) {
	m.user_balance = &s
}

// UserBalance returns the value of the "user_balance" field in the mutation.
func (m *DelegatesMutation) UserBalance() (r string, exists bool) {
	v := m.user_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldUserBalance returns the old "user_balance" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldUserBalance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserBalance: %w", err)
	}
	return oldValue.UserBalance, nil
}

// ClearUserBalance clears the value of the "user_balance" field.
func (m *DelegatesMutation) ClearUserBalance() {
	m.user_balance = nil
	m.clearedFields[delegates.FieldUserBalance] = struct{}{}
}

// UserBalanceCleared returns if the "user_balance" field was cleared in this mutation.
func (m *DelegatesMutation) UserBalanceCleared() bool {
	_, ok := m.clearedFields[delegates.FieldUserBalance]
	return ok
}

// ResetUserBalance resets all changes to the "user_balance" field.
func (m *DelegatesMutation) ResetUserBalance() {
	m.user_balance = nil
	delete(m.clearedFields, delegates.FieldUserBalance)
}

// SetAmount sets the "amount" field.
func (m *DelegatesMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *DelegatesMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *DelegatesMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[delegates.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *DelegatesMutation) AmountCleared() bool {
	_, ok := m.clearedFields[delegates.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *DelegatesMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, delegates.FieldAmount)
}

// SetCreatedAt sets the "created_at" field.
func (m *DelegatesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DelegatesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DelegatesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[delegates.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DelegatesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[delegates.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DelegatesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, delegates.FieldCreatedAt)
}

// SetStatus sets the "status" field.
func (m *DelegatesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DelegatesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *DelegatesMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[delegates.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DelegatesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[delegates.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DelegatesMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, delegates.FieldStatus)
}

// SetDeploy sets the "Deploy" field.
func (m *DelegatesMutation) SetDeploy(s string) {
	m._Deploy = &s
}

// Deploy returns the value of the "Deploy" field in the mutation.
func (m *DelegatesMutation) Deploy() (r string, exists bool) {
	v := m._Deploy
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploy returns the old "Deploy" field's value of the Delegates entity.
// If the Delegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelegatesMutation) OldDeploy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploy: %w", err)
	}
	return oldValue.Deploy, nil
}

// ClearDeploy clears the value of the "Deploy" field.
func (m *DelegatesMutation) ClearDeploy() {
	m._Deploy = nil
	m.clearedFields[delegates.FieldDeploy] = struct{}{}
}

// DeployCleared returns if the "Deploy" field was cleared in this mutation.
func (m *DelegatesMutation) DeployCleared() bool {
	_, ok := m.clearedFields[delegates.FieldDeploy]
	return ok
}

// ResetDeploy resets all changes to the "Deploy" field.
func (m *DelegatesMutation) ResetDeploy() {
	m._Deploy = nil
	delete(m.clearedFields, delegates.FieldDeploy)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *DelegatesMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *DelegatesMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *DelegatesMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DelegatesMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DelegatesMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DelegatesMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the DelegatesMutation builder.
func (m *DelegatesMutation) Where(ps ...predicate.Delegates) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DelegatesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DelegatesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Delegates, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DelegatesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DelegatesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Delegates).
func (m *DelegatesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DelegatesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.delegator != nil {
		fields = append(fields, delegates.FieldDelegator)
	}
	if m.validator != nil {
		fields = append(fields, delegates.FieldValidator)
	}
	if m.name != nil {
		fields = append(fields, delegates.FieldName)
	}
	if m.user_balance != nil {
		fields = append(fields, delegates.FieldUserBalance)
	}
	if m.amount != nil {
		fields = append(fields, delegates.FieldAmount)
	}
	if m.created_at != nil {
		fields = append(fields, delegates.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, delegates.FieldStatus)
	}
	if m._Deploy != nil {
		fields = append(fields, delegates.FieldDeploy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DelegatesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case delegates.FieldDelegator:
		return m.Delegator()
	case delegates.FieldValidator:
		return m.Validator()
	case delegates.FieldName:
		return m.Name()
	case delegates.FieldUserBalance:
		return m.UserBalance()
	case delegates.FieldAmount:
		return m.Amount()
	case delegates.FieldCreatedAt:
		return m.CreatedAt()
	case delegates.FieldStatus:
		return m.Status()
	case delegates.FieldDeploy:
		return m.Deploy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DelegatesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case delegates.FieldDelegator:
		return m.OldDelegator(ctx)
	case delegates.FieldValidator:
		return m.OldValidator(ctx)
	case delegates.FieldName:
		return m.OldName(ctx)
	case delegates.FieldUserBalance:
		return m.OldUserBalance(ctx)
	case delegates.FieldAmount:
		return m.OldAmount(ctx)
	case delegates.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case delegates.FieldStatus:
		return m.OldStatus(ctx)
	case delegates.FieldDeploy:
		return m.OldDeploy(ctx)
	}
	return nil, fmt.Errorf("unknown Delegates field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelegatesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case delegates.FieldDelegator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegator(v)
		return nil
	case delegates.FieldValidator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidator(v)
		return nil
	case delegates.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case delegates.FieldUserBalance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserBalance(v)
		return nil
	case delegates.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case delegates.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case delegates.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case delegates.FieldDeploy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploy(v)
		return nil
	}
	return fmt.Errorf("unknown Delegates field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DelegatesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DelegatesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelegatesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Delegates numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DelegatesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(delegates.FieldValidator) {
		fields = append(fields, delegates.FieldValidator)
	}
	if m.FieldCleared(delegates.FieldName) {
		fields = append(fields, delegates.FieldName)
	}
	if m.FieldCleared(delegates.FieldUserBalance) {
		fields = append(fields, delegates.FieldUserBalance)
	}
	if m.FieldCleared(delegates.FieldAmount) {
		fields = append(fields, delegates.FieldAmount)
	}
	if m.FieldCleared(delegates.FieldCreatedAt) {
		fields = append(fields, delegates.FieldCreatedAt)
	}
	if m.FieldCleared(delegates.FieldStatus) {
		fields = append(fields, delegates.FieldStatus)
	}
	if m.FieldCleared(delegates.FieldDeploy) {
		fields = append(fields, delegates.FieldDeploy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DelegatesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DelegatesMutation) ClearField(name string) error {
	switch name {
	case delegates.FieldValidator:
		m.ClearValidator()
		return nil
	case delegates.FieldName:
		m.ClearName()
		return nil
	case delegates.FieldUserBalance:
		m.ClearUserBalance()
		return nil
	case delegates.FieldAmount:
		m.ClearAmount()
		return nil
	case delegates.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case delegates.FieldStatus:
		m.ClearStatus()
		return nil
	case delegates.FieldDeploy:
		m.ClearDeploy()
		return nil
	}
	return fmt.Errorf("unknown Delegates nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DelegatesMutation) ResetField(name string) error {
	switch name {
	case delegates.FieldDelegator:
		m.ResetDelegator()
		return nil
	case delegates.FieldValidator:
		m.ResetValidator()
		return nil
	case delegates.FieldName:
		m.ResetName()
		return nil
	case delegates.FieldUserBalance:
		m.ResetUserBalance()
		return nil
	case delegates.FieldAmount:
		m.ResetAmount()
		return nil
	case delegates.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case delegates.FieldStatus:
		m.ResetStatus()
		return nil
	case delegates.FieldDeploy:
		m.ResetDeploy()
		return nil
	}
	return fmt.Errorf("unknown Delegates field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DelegatesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, delegates.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DelegatesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case delegates.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DelegatesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DelegatesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DelegatesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, delegates.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DelegatesMutation) EdgeCleared(name string) bool {
	switch name {
	case delegates.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DelegatesMutation) ClearEdge(name string) error {
	switch name {
	case delegates.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Delegates unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DelegatesMutation) ResetEdge(name string) error {
	switch name {
	case delegates.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Delegates edge %s", name)
}

// InvoiceMutation represents an operation that mutates the Invoice nodes in the graph.
type InvoiceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	address          *string
	amount           *string
	currency         *string
	comment          *string
	active           *bool
	repeatability    *int
	addrepeatability *int
	paid             *int
	addpaid          *int
	short            *string
	memo             *uint64
	addmemo          *int64
	clearedFields    map[string]struct{}
	owner            *int64
	clearedowner     bool
	payments         map[int]struct{}
	removedpayments  map[int]struct{}
	clearedpayments  bool
	done             bool
	oldValue         func(context.Context) (*Invoice, error)
	predicates       []predicate.Invoice
}

var _ ent.Mutation = (*InvoiceMutation)(nil)

// invoiceOption allows management of the mutation configuration using functional options.
type invoiceOption func(*InvoiceMutation)

// newInvoiceMutation creates new mutation for the Invoice entity.
func newInvoiceMutation(c config, op Op, opts ...invoiceOption) *InvoiceMutation {
	m := &InvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceID sets the ID field of the mutation.
func withInvoiceID(id int) invoiceOption {
	return func(m *InvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoice
		)
		m.oldValue = func(ctx context.Context) (*Invoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoice sets the old Invoice of the mutation.
func withInvoice(node *Invoice) invoiceOption {
	return func(m *InvoiceMutation) {
		m.oldValue = func(context.Context) (*Invoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *InvoiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InvoiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *InvoiceMutation) ClearName() {
	m.name = nil
	m.clearedFields[invoice.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *InvoiceMutation) NameCleared() bool {
	_, ok := m.clearedFields[invoice.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *InvoiceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, invoice.FieldName)
}

// SetAddress sets the "address" field.
func (m *InvoiceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *InvoiceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *InvoiceMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[invoice.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *InvoiceMutation) AddressCleared() bool {
	_, ok := m.clearedFields[invoice.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *InvoiceMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, invoice.FieldAddress)
}

// SetAmount sets the "amount" field.
func (m *InvoiceMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *InvoiceMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *InvoiceMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[invoice.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *InvoiceMutation) AmountCleared() bool {
	_, ok := m.clearedFields[invoice.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *InvoiceMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, invoice.FieldAmount)
}

// SetCurrency sets the "currency" field.
func (m *InvoiceMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *InvoiceMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *InvoiceMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[invoice.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *InvoiceMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[invoice.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *InvoiceMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, invoice.FieldCurrency)
}

// SetComment sets the "comment" field.
func (m *InvoiceMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *InvoiceMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *InvoiceMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[invoice.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *InvoiceMutation) CommentCleared() bool {
	_, ok := m.clearedFields[invoice.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *InvoiceMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, invoice.FieldComment)
}

// SetActive sets the "active" field.
func (m *InvoiceMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *InvoiceMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ClearActive clears the value of the "active" field.
func (m *InvoiceMutation) ClearActive() {
	m.active = nil
	m.clearedFields[invoice.FieldActive] = struct{}{}
}

// ActiveCleared returns if the "active" field was cleared in this mutation.
func (m *InvoiceMutation) ActiveCleared() bool {
	_, ok := m.clearedFields[invoice.FieldActive]
	return ok
}

// ResetActive resets all changes to the "active" field.
func (m *InvoiceMutation) ResetActive() {
	m.active = nil
	delete(m.clearedFields, invoice.FieldActive)
}

// SetRepeatability sets the "repeatability" field.
func (m *InvoiceMutation) SetRepeatability(i int) {
	m.repeatability = &i
	m.addrepeatability = nil
}

// Repeatability returns the value of the "repeatability" field in the mutation.
func (m *InvoiceMutation) Repeatability() (r int, exists bool) {
	v := m.repeatability
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatability returns the old "repeatability" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldRepeatability(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatability: %w", err)
	}
	return oldValue.Repeatability, nil
}

// AddRepeatability adds i to the "repeatability" field.
func (m *InvoiceMutation) AddRepeatability(i int) {
	if m.addrepeatability != nil {
		*m.addrepeatability += i
	} else {
		m.addrepeatability = &i
	}
}

// AddedRepeatability returns the value that was added to the "repeatability" field in this mutation.
func (m *InvoiceMutation) AddedRepeatability() (r int, exists bool) {
	v := m.addrepeatability
	if v == nil {
		return
	}
	return *v, true
}

// ClearRepeatability clears the value of the "repeatability" field.
func (m *InvoiceMutation) ClearRepeatability() {
	m.repeatability = nil
	m.addrepeatability = nil
	m.clearedFields[invoice.FieldRepeatability] = struct{}{}
}

// RepeatabilityCleared returns if the "repeatability" field was cleared in this mutation.
func (m *InvoiceMutation) RepeatabilityCleared() bool {
	_, ok := m.clearedFields[invoice.FieldRepeatability]
	return ok
}

// ResetRepeatability resets all changes to the "repeatability" field.
func (m *InvoiceMutation) ResetRepeatability() {
	m.repeatability = nil
	m.addrepeatability = nil
	delete(m.clearedFields, invoice.FieldRepeatability)
}

// SetPaid sets the "paid" field.
func (m *InvoiceMutation) SetPaid(i int) {
	m.paid = &i
	m.addpaid = nil
}

// Paid returns the value of the "paid" field in the mutation.
func (m *InvoiceMutation) Paid() (r int, exists bool) {
	v := m.paid
	if v == nil {
		return
	}
	return *v, true
}

// OldPaid returns the old "paid" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldPaid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaid: %w", err)
	}
	return oldValue.Paid, nil
}

// AddPaid adds i to the "paid" field.
func (m *InvoiceMutation) AddPaid(i int) {
	if m.addpaid != nil {
		*m.addpaid += i
	} else {
		m.addpaid = &i
	}
}

// AddedPaid returns the value that was added to the "paid" field in this mutation.
func (m *InvoiceMutation) AddedPaid() (r int, exists bool) {
	v := m.addpaid
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaid clears the value of the "paid" field.
func (m *InvoiceMutation) ClearPaid() {
	m.paid = nil
	m.addpaid = nil
	m.clearedFields[invoice.FieldPaid] = struct{}{}
}

// PaidCleared returns if the "paid" field was cleared in this mutation.
func (m *InvoiceMutation) PaidCleared() bool {
	_, ok := m.clearedFields[invoice.FieldPaid]
	return ok
}

// ResetPaid resets all changes to the "paid" field.
func (m *InvoiceMutation) ResetPaid() {
	m.paid = nil
	m.addpaid = nil
	delete(m.clearedFields, invoice.FieldPaid)
}

// SetShort sets the "short" field.
func (m *InvoiceMutation) SetShort(s string) {
	m.short = &s
}

// Short returns the value of the "short" field in the mutation.
func (m *InvoiceMutation) Short() (r string, exists bool) {
	v := m.short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "short" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ClearShort clears the value of the "short" field.
func (m *InvoiceMutation) ClearShort() {
	m.short = nil
	m.clearedFields[invoice.FieldShort] = struct{}{}
}

// ShortCleared returns if the "short" field was cleared in this mutation.
func (m *InvoiceMutation) ShortCleared() bool {
	_, ok := m.clearedFields[invoice.FieldShort]
	return ok
}

// ResetShort resets all changes to the "short" field.
func (m *InvoiceMutation) ResetShort() {
	m.short = nil
	delete(m.clearedFields, invoice.FieldShort)
}

// SetMemo sets the "memo" field.
func (m *InvoiceMutation) SetMemo(u uint64) {
	m.memo = &u
	m.addmemo = nil
}

// Memo returns the value of the "memo" field in the mutation.
func (m *InvoiceMutation) Memo() (r uint64, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old "memo" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldMemo(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// AddMemo adds u to the "memo" field.
func (m *InvoiceMutation) AddMemo(u int64) {
	if m.addmemo != nil {
		*m.addmemo += u
	} else {
		m.addmemo = &u
	}
}

// AddedMemo returns the value that was added to the "memo" field in this mutation.
func (m *InvoiceMutation) AddedMemo() (r int64, exists bool) {
	v := m.addmemo
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemo clears the value of the "memo" field.
func (m *InvoiceMutation) ClearMemo() {
	m.memo = nil
	m.addmemo = nil
	m.clearedFields[invoice.FieldMemo] = struct{}{}
}

// MemoCleared returns if the "memo" field was cleared in this mutation.
func (m *InvoiceMutation) MemoCleared() bool {
	_, ok := m.clearedFields[invoice.FieldMemo]
	return ok
}

// ResetMemo resets all changes to the "memo" field.
func (m *InvoiceMutation) ResetMemo() {
	m.memo = nil
	m.addmemo = nil
	delete(m.clearedFields, invoice.FieldMemo)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *InvoiceMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *InvoiceMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *InvoiceMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *InvoiceMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *InvoiceMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddPaymentIDs adds the "payments" edge to the Invoices_payments entity by ids.
func (m *InvoiceMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the Invoices_payments entity.
func (m *InvoiceMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the Invoices_payments entity was cleared.
func (m *InvoiceMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the Invoices_payments entity by IDs.
func (m *InvoiceMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the Invoices_payments entity.
func (m *InvoiceMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *InvoiceMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *InvoiceMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// Where appends a list predicates to the InvoiceMutation builder.
func (m *InvoiceMutation) Where(ps ...predicate.Invoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoice).
func (m *InvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, invoice.FieldName)
	}
	if m.address != nil {
		fields = append(fields, invoice.FieldAddress)
	}
	if m.amount != nil {
		fields = append(fields, invoice.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, invoice.FieldCurrency)
	}
	if m.comment != nil {
		fields = append(fields, invoice.FieldComment)
	}
	if m.active != nil {
		fields = append(fields, invoice.FieldActive)
	}
	if m.repeatability != nil {
		fields = append(fields, invoice.FieldRepeatability)
	}
	if m.paid != nil {
		fields = append(fields, invoice.FieldPaid)
	}
	if m.short != nil {
		fields = append(fields, invoice.FieldShort)
	}
	if m.memo != nil {
		fields = append(fields, invoice.FieldMemo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldName:
		return m.Name()
	case invoice.FieldAddress:
		return m.Address()
	case invoice.FieldAmount:
		return m.Amount()
	case invoice.FieldCurrency:
		return m.Currency()
	case invoice.FieldComment:
		return m.Comment()
	case invoice.FieldActive:
		return m.Active()
	case invoice.FieldRepeatability:
		return m.Repeatability()
	case invoice.FieldPaid:
		return m.Paid()
	case invoice.FieldShort:
		return m.Short()
	case invoice.FieldMemo:
		return m.Memo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoice.FieldName:
		return m.OldName(ctx)
	case invoice.FieldAddress:
		return m.OldAddress(ctx)
	case invoice.FieldAmount:
		return m.OldAmount(ctx)
	case invoice.FieldCurrency:
		return m.OldCurrency(ctx)
	case invoice.FieldComment:
		return m.OldComment(ctx)
	case invoice.FieldActive:
		return m.OldActive(ctx)
	case invoice.FieldRepeatability:
		return m.OldRepeatability(ctx)
	case invoice.FieldPaid:
		return m.OldPaid(ctx)
	case invoice.FieldShort:
		return m.OldShort(ctx)
	case invoice.FieldMemo:
		return m.OldMemo(ctx)
	}
	return nil, fmt.Errorf("unknown Invoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case invoice.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case invoice.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case invoice.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case invoice.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case invoice.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case invoice.FieldRepeatability:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatability(v)
		return nil
	case invoice.FieldPaid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaid(v)
		return nil
	case invoice.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case invoice.FieldMemo:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addrepeatability != nil {
		fields = append(fields, invoice.FieldRepeatability)
	}
	if m.addpaid != nil {
		fields = append(fields, invoice.FieldPaid)
	}
	if m.addmemo != nil {
		fields = append(fields, invoice.FieldMemo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldRepeatability:
		return m.AddedRepeatability()
	case invoice.FieldPaid:
		return m.AddedPaid()
	case invoice.FieldMemo:
		return m.AddedMemo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldRepeatability:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepeatability(v)
		return nil
	case invoice.FieldPaid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaid(v)
		return nil
	case invoice.FieldMemo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemo(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoice.FieldName) {
		fields = append(fields, invoice.FieldName)
	}
	if m.FieldCleared(invoice.FieldAddress) {
		fields = append(fields, invoice.FieldAddress)
	}
	if m.FieldCleared(invoice.FieldAmount) {
		fields = append(fields, invoice.FieldAmount)
	}
	if m.FieldCleared(invoice.FieldCurrency) {
		fields = append(fields, invoice.FieldCurrency)
	}
	if m.FieldCleared(invoice.FieldComment) {
		fields = append(fields, invoice.FieldComment)
	}
	if m.FieldCleared(invoice.FieldActive) {
		fields = append(fields, invoice.FieldActive)
	}
	if m.FieldCleared(invoice.FieldRepeatability) {
		fields = append(fields, invoice.FieldRepeatability)
	}
	if m.FieldCleared(invoice.FieldPaid) {
		fields = append(fields, invoice.FieldPaid)
	}
	if m.FieldCleared(invoice.FieldShort) {
		fields = append(fields, invoice.FieldShort)
	}
	if m.FieldCleared(invoice.FieldMemo) {
		fields = append(fields, invoice.FieldMemo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceMutation) ClearField(name string) error {
	switch name {
	case invoice.FieldName:
		m.ClearName()
		return nil
	case invoice.FieldAddress:
		m.ClearAddress()
		return nil
	case invoice.FieldAmount:
		m.ClearAmount()
		return nil
	case invoice.FieldCurrency:
		m.ClearCurrency()
		return nil
	case invoice.FieldComment:
		m.ClearComment()
		return nil
	case invoice.FieldActive:
		m.ClearActive()
		return nil
	case invoice.FieldRepeatability:
		m.ClearRepeatability()
		return nil
	case invoice.FieldPaid:
		m.ClearPaid()
		return nil
	case invoice.FieldShort:
		m.ClearShort()
		return nil
	case invoice.FieldMemo:
		m.ClearMemo()
		return nil
	}
	return fmt.Errorf("unknown Invoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceMutation) ResetField(name string) error {
	switch name {
	case invoice.FieldName:
		m.ResetName()
		return nil
	case invoice.FieldAddress:
		m.ResetAddress()
		return nil
	case invoice.FieldAmount:
		m.ResetAmount()
		return nil
	case invoice.FieldCurrency:
		m.ResetCurrency()
		return nil
	case invoice.FieldComment:
		m.ResetComment()
		return nil
	case invoice.FieldActive:
		m.ResetActive()
		return nil
	case invoice.FieldRepeatability:
		m.ResetRepeatability()
		return nil
	case invoice.FieldPaid:
		m.ResetPaid()
		return nil
	case invoice.FieldShort:
		m.ResetShort()
		return nil
	case invoice.FieldMemo:
		m.ResetMemo()
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, invoice.EdgeOwner)
	}
	if m.payments != nil {
		edges = append(edges, invoice.EdgePayments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case invoice.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpayments != nil {
		edges = append(edges, invoice.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, invoice.EdgeOwner)
	}
	if m.clearedpayments {
		edges = append(edges, invoice.EdgePayments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case invoice.EdgeOwner:
		return m.clearedowner
	case invoice.EdgePayments:
		return m.clearedpayments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceMutation) ClearEdge(name string) error {
	switch name {
	case invoice.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Invoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceMutation) ResetEdge(name string) error {
	switch name {
	case invoice.EdgeOwner:
		m.ResetOwner()
		return nil
	case invoice.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown Invoice edge %s", name)
}

// InvoicesPaymentsMutation represents an operation that mutates the Invoices_payments nodes in the graph.
type InvoicesPaymentsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	from           *string
	amount         *string
	correct        *bool
	clearedFields  map[string]struct{}
	invoice        *int
	clearedinvoice bool
	done           bool
	oldValue       func(context.Context) (*Invoices_payments, error)
	predicates     []predicate.Invoices_payments
}

var _ ent.Mutation = (*InvoicesPaymentsMutation)(nil)

// invoicesPaymentsOption allows management of the mutation configuration using functional options.
type invoicesPaymentsOption func(*InvoicesPaymentsMutation)

// newInvoicesPaymentsMutation creates new mutation for the Invoices_payments entity.
func newInvoicesPaymentsMutation(c config, op Op, opts ...invoicesPaymentsOption) *InvoicesPaymentsMutation {
	m := &InvoicesPaymentsMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoicesPayments,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoices_paymentsID sets the ID field of the mutation.
func withInvoices_paymentsID(id int) invoicesPaymentsOption {
	return func(m *InvoicesPaymentsMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoices_payments
		)
		m.oldValue = func(ctx context.Context) (*Invoices_payments, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoices_payments.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoices_payments sets the old Invoices_payments of the mutation.
func withInvoices_payments(node *Invoices_payments) invoicesPaymentsOption {
	return func(m *InvoicesPaymentsMutation) {
		m.oldValue = func(context.Context) (*Invoices_payments, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoicesPaymentsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoicesPaymentsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoicesPaymentsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoicesPaymentsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoices_payments.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFrom sets the "from" field.
func (m *InvoicesPaymentsMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the value of the "from" field in the mutation.
func (m *InvoicesPaymentsMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the Invoices_payments entity.
// If the Invoices_payments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoicesPaymentsMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ClearFrom clears the value of the "from" field.
func (m *InvoicesPaymentsMutation) ClearFrom() {
	m.from = nil
	m.clearedFields[invoices_payments.FieldFrom] = struct{}{}
}

// FromCleared returns if the "from" field was cleared in this mutation.
func (m *InvoicesPaymentsMutation) FromCleared() bool {
	_, ok := m.clearedFields[invoices_payments.FieldFrom]
	return ok
}

// ResetFrom resets all changes to the "from" field.
func (m *InvoicesPaymentsMutation) ResetFrom() {
	m.from = nil
	delete(m.clearedFields, invoices_payments.FieldFrom)
}

// SetAmount sets the "amount" field.
func (m *InvoicesPaymentsMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *InvoicesPaymentsMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Invoices_payments entity.
// If the Invoices_payments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoicesPaymentsMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *InvoicesPaymentsMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[invoices_payments.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *InvoicesPaymentsMutation) AmountCleared() bool {
	_, ok := m.clearedFields[invoices_payments.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *InvoicesPaymentsMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, invoices_payments.FieldAmount)
}

// SetCorrect sets the "correct" field.
func (m *InvoicesPaymentsMutation) SetCorrect(b bool) {
	m.correct = &b
}

// Correct returns the value of the "correct" field in the mutation.
func (m *InvoicesPaymentsMutation) Correct() (r bool, exists bool) {
	v := m.correct
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrect returns the old "correct" field's value of the Invoices_payments entity.
// If the Invoices_payments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoicesPaymentsMutation) OldCorrect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrect: %w", err)
	}
	return oldValue.Correct, nil
}

// ClearCorrect clears the value of the "correct" field.
func (m *InvoicesPaymentsMutation) ClearCorrect() {
	m.correct = nil
	m.clearedFields[invoices_payments.FieldCorrect] = struct{}{}
}

// CorrectCleared returns if the "correct" field was cleared in this mutation.
func (m *InvoicesPaymentsMutation) CorrectCleared() bool {
	_, ok := m.clearedFields[invoices_payments.FieldCorrect]
	return ok
}

// ResetCorrect resets all changes to the "correct" field.
func (m *InvoicesPaymentsMutation) ResetCorrect() {
	m.correct = nil
	delete(m.clearedFields, invoices_payments.FieldCorrect)
}

// SetInvoiceID sets the "invoice" edge to the Invoice entity by id.
func (m *InvoicesPaymentsMutation) SetInvoiceID(id int) {
	m.invoice = &id
}

// ClearInvoice clears the "invoice" edge to the Invoice entity.
func (m *InvoicesPaymentsMutation) ClearInvoice() {
	m.clearedinvoice = true
}

// InvoiceCleared reports if the "invoice" edge to the Invoice entity was cleared.
func (m *InvoicesPaymentsMutation) InvoiceCleared() bool {
	return m.clearedinvoice
}

// InvoiceID returns the "invoice" edge ID in the mutation.
func (m *InvoicesPaymentsMutation) InvoiceID() (id int, exists bool) {
	if m.invoice != nil {
		return *m.invoice, true
	}
	return
}

// InvoiceIDs returns the "invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceID instead. It exists only for internal usage by the builders.
func (m *InvoicesPaymentsMutation) InvoiceIDs() (ids []int) {
	if id := m.invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoice resets all changes to the "invoice" edge.
func (m *InvoicesPaymentsMutation) ResetInvoice() {
	m.invoice = nil
	m.clearedinvoice = false
}

// Where appends a list predicates to the InvoicesPaymentsMutation builder.
func (m *InvoicesPaymentsMutation) Where(ps ...predicate.Invoices_payments) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoicesPaymentsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoicesPaymentsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoices_payments, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoicesPaymentsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoicesPaymentsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoices_payments).
func (m *InvoicesPaymentsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoicesPaymentsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.from != nil {
		fields = append(fields, invoices_payments.FieldFrom)
	}
	if m.amount != nil {
		fields = append(fields, invoices_payments.FieldAmount)
	}
	if m.correct != nil {
		fields = append(fields, invoices_payments.FieldCorrect)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoicesPaymentsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoices_payments.FieldFrom:
		return m.From()
	case invoices_payments.FieldAmount:
		return m.Amount()
	case invoices_payments.FieldCorrect:
		return m.Correct()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoicesPaymentsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoices_payments.FieldFrom:
		return m.OldFrom(ctx)
	case invoices_payments.FieldAmount:
		return m.OldAmount(ctx)
	case invoices_payments.FieldCorrect:
		return m.OldCorrect(ctx)
	}
	return nil, fmt.Errorf("unknown Invoices_payments field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoicesPaymentsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoices_payments.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case invoices_payments.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case invoices_payments.FieldCorrect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrect(v)
		return nil
	}
	return fmt.Errorf("unknown Invoices_payments field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoicesPaymentsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoicesPaymentsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoicesPaymentsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invoices_payments numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoicesPaymentsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoices_payments.FieldFrom) {
		fields = append(fields, invoices_payments.FieldFrom)
	}
	if m.FieldCleared(invoices_payments.FieldAmount) {
		fields = append(fields, invoices_payments.FieldAmount)
	}
	if m.FieldCleared(invoices_payments.FieldCorrect) {
		fields = append(fields, invoices_payments.FieldCorrect)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoicesPaymentsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoicesPaymentsMutation) ClearField(name string) error {
	switch name {
	case invoices_payments.FieldFrom:
		m.ClearFrom()
		return nil
	case invoices_payments.FieldAmount:
		m.ClearAmount()
		return nil
	case invoices_payments.FieldCorrect:
		m.ClearCorrect()
		return nil
	}
	return fmt.Errorf("unknown Invoices_payments nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoicesPaymentsMutation) ResetField(name string) error {
	switch name {
	case invoices_payments.FieldFrom:
		m.ResetFrom()
		return nil
	case invoices_payments.FieldAmount:
		m.ResetAmount()
		return nil
	case invoices_payments.FieldCorrect:
		m.ResetCorrect()
		return nil
	}
	return fmt.Errorf("unknown Invoices_payments field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoicesPaymentsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.invoice != nil {
		edges = append(edges, invoices_payments.EdgeInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoicesPaymentsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoices_payments.EdgeInvoice:
		if id := m.invoice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoicesPaymentsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoicesPaymentsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoicesPaymentsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinvoice {
		edges = append(edges, invoices_payments.EdgeInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoicesPaymentsMutation) EdgeCleared(name string) bool {
	switch name {
	case invoices_payments.EdgeInvoice:
		return m.clearedinvoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoicesPaymentsMutation) ClearEdge(name string) error {
	switch name {
	case invoices_payments.EdgeInvoice:
		m.ClearInvoice()
		return nil
	}
	return fmt.Errorf("unknown Invoices_payments unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoicesPaymentsMutation) ResetEdge(name string) error {
	switch name {
	case invoices_payments.EdgeInvoice:
		m.ResetInvoice()
		return nil
	}
	return fmt.Errorf("unknown Invoices_payments edge %s", name)
}

// PrivateKeysMutation represents an operation that mutates the PrivateKeys nodes in the graph.
type PrivateKeysMutation struct {
	config
	op            Op
	typ           string
	id            *int
	private_key   *[]byte
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PrivateKeys, error)
	predicates    []predicate.PrivateKeys
}

var _ ent.Mutation = (*PrivateKeysMutation)(nil)

// privatekeysOption allows management of the mutation configuration using functional options.
type privatekeysOption func(*PrivateKeysMutation)

// newPrivateKeysMutation creates new mutation for the PrivateKeys entity.
func newPrivateKeysMutation(c config, op Op, opts ...privatekeysOption) *PrivateKeysMutation {
	m := &PrivateKeysMutation{
		config:        c,
		op:            op,
		typ:           TypePrivateKeys,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrivateKeysID sets the ID field of the mutation.
func withPrivateKeysID(id int) privatekeysOption {
	return func(m *PrivateKeysMutation) {
		var (
			err   error
			once  sync.Once
			value *PrivateKeys
		)
		m.oldValue = func(ctx context.Context) (*PrivateKeys, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrivateKeys.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrivateKeys sets the old PrivateKeys of the mutation.
func withPrivateKeys(node *PrivateKeys) privatekeysOption {
	return func(m *PrivateKeysMutation) {
		m.oldValue = func(context.Context) (*PrivateKeys, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrivateKeysMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrivateKeysMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrivateKeysMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrivateKeysMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PrivateKeys.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrivateKey sets the "private_key" field.
func (m *PrivateKeysMutation) SetPrivateKey(b []byte) {
	m.private_key = &b
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *PrivateKeysMutation) PrivateKey() (r []byte, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the PrivateKeys entity.
// If the PrivateKeys object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivateKeysMutation) OldPrivateKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ClearPrivateKey clears the value of the "private_key" field.
func (m *PrivateKeysMutation) ClearPrivateKey() {
	m.private_key = nil
	m.clearedFields[privatekeys.FieldPrivateKey] = struct{}{}
}

// PrivateKeyCleared returns if the "private_key" field was cleared in this mutation.
func (m *PrivateKeysMutation) PrivateKeyCleared() bool {
	_, ok := m.clearedFields[privatekeys.FieldPrivateKey]
	return ok
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *PrivateKeysMutation) ResetPrivateKey() {
	m.private_key = nil
	delete(m.clearedFields, privatekeys.FieldPrivateKey)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *PrivateKeysMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *PrivateKeysMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *PrivateKeysMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PrivateKeysMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PrivateKeysMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PrivateKeysMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PrivateKeysMutation builder.
func (m *PrivateKeysMutation) Where(ps ...predicate.PrivateKeys) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrivateKeysMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrivateKeysMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PrivateKeys, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrivateKeysMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrivateKeysMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PrivateKeys).
func (m *PrivateKeysMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrivateKeysMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.private_key != nil {
		fields = append(fields, privatekeys.FieldPrivateKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrivateKeysMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case privatekeys.FieldPrivateKey:
		return m.PrivateKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrivateKeysMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case privatekeys.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	}
	return nil, fmt.Errorf("unknown PrivateKeys field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrivateKeysMutation) SetField(name string, value ent.Value) error {
	switch name {
	case privatekeys.FieldPrivateKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	}
	return fmt.Errorf("unknown PrivateKeys field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrivateKeysMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrivateKeysMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrivateKeysMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PrivateKeys numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrivateKeysMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(privatekeys.FieldPrivateKey) {
		fields = append(fields, privatekeys.FieldPrivateKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrivateKeysMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrivateKeysMutation) ClearField(name string) error {
	switch name {
	case privatekeys.FieldPrivateKey:
		m.ClearPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown PrivateKeys nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrivateKeysMutation) ResetField(name string) error {
	switch name {
	case privatekeys.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown PrivateKeys field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrivateKeysMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, privatekeys.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrivateKeysMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case privatekeys.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrivateKeysMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrivateKeysMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrivateKeysMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, privatekeys.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrivateKeysMutation) EdgeCleared(name string) bool {
	switch name {
	case privatekeys.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrivateKeysMutation) ClearEdge(name string) error {
	switch name {
	case privatekeys.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PrivateKeys unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrivateKeysMutation) ResetEdge(name string) error {
	switch name {
	case privatekeys.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PrivateKeys edge %s", name)
}

// RecentInvoicesMutation represents an operation that mutates the RecentInvoices nodes in the graph.
type RecentInvoicesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *string
	invoiceID     *int64
	addinvoiceID  *int64
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*RecentInvoices, error)
	predicates    []predicate.RecentInvoices
}

var _ ent.Mutation = (*RecentInvoicesMutation)(nil)

// recentinvoicesOption allows management of the mutation configuration using functional options.
type recentinvoicesOption func(*RecentInvoicesMutation)

// newRecentInvoicesMutation creates new mutation for the RecentInvoices entity.
func newRecentInvoicesMutation(c config, op Op, opts ...recentinvoicesOption) *RecentInvoicesMutation {
	m := &RecentInvoicesMutation{
		config:        c,
		op:            op,
		typ:           TypeRecentInvoices,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecentInvoicesID sets the ID field of the mutation.
func withRecentInvoicesID(id int) recentinvoicesOption {
	return func(m *RecentInvoicesMutation) {
		var (
			err   error
			once  sync.Once
			value *RecentInvoices
		)
		m.oldValue = func(ctx context.Context) (*RecentInvoices, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecentInvoices.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecentInvoices sets the old RecentInvoices of the mutation.
func withRecentInvoices(node *RecentInvoices) recentinvoicesOption {
	return func(m *RecentInvoicesMutation) {
		m.oldValue = func(context.Context) (*RecentInvoices, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecentInvoicesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecentInvoicesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecentInvoicesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecentInvoicesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecentInvoices.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *RecentInvoicesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RecentInvoicesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RecentInvoices entity.
// If the RecentInvoices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentInvoicesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RecentInvoicesMutation) ResetStatus() {
	m.status = nil
}

// SetInvoiceID sets the "invoiceID" field.
func (m *RecentInvoicesMutation) SetInvoiceID(i int64) {
	m.invoiceID = &i
	m.addinvoiceID = nil
}

// InvoiceID returns the value of the "invoiceID" field in the mutation.
func (m *RecentInvoicesMutation) InvoiceID() (r int64, exists bool) {
	v := m.invoiceID
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoiceID" field's value of the RecentInvoices entity.
// If the RecentInvoices object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentInvoicesMutation) OldInvoiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// AddInvoiceID adds i to the "invoiceID" field.
func (m *RecentInvoicesMutation) AddInvoiceID(i int64) {
	if m.addinvoiceID != nil {
		*m.addinvoiceID += i
	} else {
		m.addinvoiceID = &i
	}
}

// AddedInvoiceID returns the value that was added to the "invoiceID" field in this mutation.
func (m *RecentInvoicesMutation) AddedInvoiceID() (r int64, exists bool) {
	v := m.addinvoiceID
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceID resets all changes to the "invoiceID" field.
func (m *RecentInvoicesMutation) ResetInvoiceID() {
	m.invoiceID = nil
	m.addinvoiceID = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *RecentInvoicesMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *RecentInvoicesMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *RecentInvoicesMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *RecentInvoicesMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *RecentInvoicesMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *RecentInvoicesMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the RecentInvoicesMutation builder.
func (m *RecentInvoicesMutation) Where(ps ...predicate.RecentInvoices) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecentInvoicesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecentInvoicesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecentInvoices, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecentInvoicesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecentInvoicesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecentInvoices).
func (m *RecentInvoicesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecentInvoicesMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status != nil {
		fields = append(fields, recentinvoices.FieldStatus)
	}
	if m.invoiceID != nil {
		fields = append(fields, recentinvoices.FieldInvoiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecentInvoicesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recentinvoices.FieldStatus:
		return m.Status()
	case recentinvoices.FieldInvoiceID:
		return m.InvoiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecentInvoicesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recentinvoices.FieldStatus:
		return m.OldStatus(ctx)
	case recentinvoices.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	}
	return nil, fmt.Errorf("unknown RecentInvoices field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentInvoicesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recentinvoices.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case recentinvoices.FieldInvoiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown RecentInvoices field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecentInvoicesMutation) AddedFields() []string {
	var fields []string
	if m.addinvoiceID != nil {
		fields = append(fields, recentinvoices.FieldInvoiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecentInvoicesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recentinvoices.FieldInvoiceID:
		return m.AddedInvoiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentInvoicesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recentinvoices.FieldInvoiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown RecentInvoices numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecentInvoicesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecentInvoicesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecentInvoicesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecentInvoices nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecentInvoicesMutation) ResetField(name string) error {
	switch name {
	case recentinvoices.FieldStatus:
		m.ResetStatus()
		return nil
	case recentinvoices.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown RecentInvoices field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecentInvoicesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, recentinvoices.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecentInvoicesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recentinvoices.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecentInvoicesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecentInvoicesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecentInvoicesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, recentinvoices.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecentInvoicesMutation) EdgeCleared(name string) bool {
	switch name {
	case recentinvoices.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecentInvoicesMutation) ClearEdge(name string) error {
	switch name {
	case recentinvoices.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown RecentInvoices unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecentInvoicesMutation) ResetEdge(name string) error {
	switch name {
	case recentinvoices.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown RecentInvoices edge %s", name)
}

// RewardsDataMutation represents an operation that mutates the RewardsData nodes in the graph.
type RewardsDataMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	validator           *string
	amount              *string
	last_reward         *time.Time
	first_era           *int64
	addfirst_era        *int64
	last_era            *int64
	addlast_era         *int64
	first_era_timestamp *string
	last_era_timestamp  *string
	clearedFields       map[string]struct{}
	owner               *int64
	clearedowner        bool
	done                bool
	oldValue            func(context.Context) (*RewardsData, error)
	predicates          []predicate.RewardsData
}

var _ ent.Mutation = (*RewardsDataMutation)(nil)

// rewardsdataOption allows management of the mutation configuration using functional options.
type rewardsdataOption func(*RewardsDataMutation)

// newRewardsDataMutation creates new mutation for the RewardsData entity.
func newRewardsDataMutation(c config, op Op, opts ...rewardsdataOption) *RewardsDataMutation {
	m := &RewardsDataMutation{
		config:        c,
		op:            op,
		typ:           TypeRewardsData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRewardsDataID sets the ID field of the mutation.
func withRewardsDataID(id int) rewardsdataOption {
	return func(m *RewardsDataMutation) {
		var (
			err   error
			once  sync.Once
			value *RewardsData
		)
		m.oldValue = func(ctx context.Context) (*RewardsData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RewardsData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRewardsData sets the old RewardsData of the mutation.
func withRewardsData(node *RewardsData) rewardsdataOption {
	return func(m *RewardsDataMutation) {
		m.oldValue = func(context.Context) (*RewardsData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RewardsDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RewardsDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RewardsDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RewardsDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RewardsData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValidator sets the "validator" field.
func (m *RewardsDataMutation) SetValidator(s string) {
	m.validator = &s
}

// Validator returns the value of the "validator" field in the mutation.
func (m *RewardsDataMutation) Validator() (r string, exists bool) {
	v := m.validator
	if v == nil {
		return
	}
	return *v, true
}

// OldValidator returns the old "validator" field's value of the RewardsData entity.
// If the RewardsData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardsDataMutation) OldValidator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidator: %w", err)
	}
	return oldValue.Validator, nil
}

// ResetValidator resets all changes to the "validator" field.
func (m *RewardsDataMutation) ResetValidator() {
	m.validator = nil
}

// SetAmount sets the "amount" field.
func (m *RewardsDataMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *RewardsDataMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the RewardsData entity.
// If the RewardsData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardsDataMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *RewardsDataMutation) ResetAmount() {
	m.amount = nil
}

// SetLastReward sets the "last_reward" field.
func (m *RewardsDataMutation) SetLastReward(t time.Time) {
	m.last_reward = &t
}

// LastReward returns the value of the "last_reward" field in the mutation.
func (m *RewardsDataMutation) LastReward() (r time.Time, exists bool) {
	v := m.last_reward
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReward returns the old "last_reward" field's value of the RewardsData entity.
// If the RewardsData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardsDataMutation) OldLastReward(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReward: %w", err)
	}
	return oldValue.LastReward, nil
}

// ResetLastReward resets all changes to the "last_reward" field.
func (m *RewardsDataMutation) ResetLastReward() {
	m.last_reward = nil
}

// SetFirstEra sets the "first_era" field.
func (m *RewardsDataMutation) SetFirstEra(i int64) {
	m.first_era = &i
	m.addfirst_era = nil
}

// FirstEra returns the value of the "first_era" field in the mutation.
func (m *RewardsDataMutation) FirstEra() (r int64, exists bool) {
	v := m.first_era
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstEra returns the old "first_era" field's value of the RewardsData entity.
// If the RewardsData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardsDataMutation) OldFirstEra(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstEra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstEra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstEra: %w", err)
	}
	return oldValue.FirstEra, nil
}

// AddFirstEra adds i to the "first_era" field.
func (m *RewardsDataMutation) AddFirstEra(i int64) {
	if m.addfirst_era != nil {
		*m.addfirst_era += i
	} else {
		m.addfirst_era = &i
	}
}

// AddedFirstEra returns the value that was added to the "first_era" field in this mutation.
func (m *RewardsDataMutation) AddedFirstEra() (r int64, exists bool) {
	v := m.addfirst_era
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstEra resets all changes to the "first_era" field.
func (m *RewardsDataMutation) ResetFirstEra() {
	m.first_era = nil
	m.addfirst_era = nil
}

// SetLastEra sets the "last_era" field.
func (m *RewardsDataMutation) SetLastEra(i int64) {
	m.last_era = &i
	m.addlast_era = nil
}

// LastEra returns the value of the "last_era" field in the mutation.
func (m *RewardsDataMutation) LastEra() (r int64, exists bool) {
	v := m.last_era
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEra returns the old "last_era" field's value of the RewardsData entity.
// If the RewardsData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardsDataMutation) OldLastEra(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEra: %w", err)
	}
	return oldValue.LastEra, nil
}

// AddLastEra adds i to the "last_era" field.
func (m *RewardsDataMutation) AddLastEra(i int64) {
	if m.addlast_era != nil {
		*m.addlast_era += i
	} else {
		m.addlast_era = &i
	}
}

// AddedLastEra returns the value that was added to the "last_era" field in this mutation.
func (m *RewardsDataMutation) AddedLastEra() (r int64, exists bool) {
	v := m.addlast_era
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastEra resets all changes to the "last_era" field.
func (m *RewardsDataMutation) ResetLastEra() {
	m.last_era = nil
	m.addlast_era = nil
}

// SetFirstEraTimestamp sets the "first_era_timestamp" field.
func (m *RewardsDataMutation) SetFirstEraTimestamp(s string) {
	m.first_era_timestamp = &s
}

// FirstEraTimestamp returns the value of the "first_era_timestamp" field in the mutation.
func (m *RewardsDataMutation) FirstEraTimestamp() (r string, exists bool) {
	v := m.first_era_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstEraTimestamp returns the old "first_era_timestamp" field's value of the RewardsData entity.
// If the RewardsData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardsDataMutation) OldFirstEraTimestamp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstEraTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstEraTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstEraTimestamp: %w", err)
	}
	return oldValue.FirstEraTimestamp, nil
}

// ResetFirstEraTimestamp resets all changes to the "first_era_timestamp" field.
func (m *RewardsDataMutation) ResetFirstEraTimestamp() {
	m.first_era_timestamp = nil
}

// SetLastEraTimestamp sets the "last_era_timestamp" field.
func (m *RewardsDataMutation) SetLastEraTimestamp(s string) {
	m.last_era_timestamp = &s
}

// LastEraTimestamp returns the value of the "last_era_timestamp" field in the mutation.
func (m *RewardsDataMutation) LastEraTimestamp() (r string, exists bool) {
	v := m.last_era_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEraTimestamp returns the old "last_era_timestamp" field's value of the RewardsData entity.
// If the RewardsData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RewardsDataMutation) OldLastEraTimestamp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEraTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEraTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEraTimestamp: %w", err)
	}
	return oldValue.LastEraTimestamp, nil
}

// ResetLastEraTimestamp resets all changes to the "last_era_timestamp" field.
func (m *RewardsDataMutation) ResetLastEraTimestamp() {
	m.last_era_timestamp = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *RewardsDataMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *RewardsDataMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *RewardsDataMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *RewardsDataMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *RewardsDataMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *RewardsDataMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the RewardsDataMutation builder.
func (m *RewardsDataMutation) Where(ps ...predicate.RewardsData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RewardsDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RewardsDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RewardsData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RewardsDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RewardsDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RewardsData).
func (m *RewardsDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RewardsDataMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.validator != nil {
		fields = append(fields, rewardsdata.FieldValidator)
	}
	if m.amount != nil {
		fields = append(fields, rewardsdata.FieldAmount)
	}
	if m.last_reward != nil {
		fields = append(fields, rewardsdata.FieldLastReward)
	}
	if m.first_era != nil {
		fields = append(fields, rewardsdata.FieldFirstEra)
	}
	if m.last_era != nil {
		fields = append(fields, rewardsdata.FieldLastEra)
	}
	if m.first_era_timestamp != nil {
		fields = append(fields, rewardsdata.FieldFirstEraTimestamp)
	}
	if m.last_era_timestamp != nil {
		fields = append(fields, rewardsdata.FieldLastEraTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RewardsDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rewardsdata.FieldValidator:
		return m.Validator()
	case rewardsdata.FieldAmount:
		return m.Amount()
	case rewardsdata.FieldLastReward:
		return m.LastReward()
	case rewardsdata.FieldFirstEra:
		return m.FirstEra()
	case rewardsdata.FieldLastEra:
		return m.LastEra()
	case rewardsdata.FieldFirstEraTimestamp:
		return m.FirstEraTimestamp()
	case rewardsdata.FieldLastEraTimestamp:
		return m.LastEraTimestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RewardsDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rewardsdata.FieldValidator:
		return m.OldValidator(ctx)
	case rewardsdata.FieldAmount:
		return m.OldAmount(ctx)
	case rewardsdata.FieldLastReward:
		return m.OldLastReward(ctx)
	case rewardsdata.FieldFirstEra:
		return m.OldFirstEra(ctx)
	case rewardsdata.FieldLastEra:
		return m.OldLastEra(ctx)
	case rewardsdata.FieldFirstEraTimestamp:
		return m.OldFirstEraTimestamp(ctx)
	case rewardsdata.FieldLastEraTimestamp:
		return m.OldLastEraTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown RewardsData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RewardsDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rewardsdata.FieldValidator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidator(v)
		return nil
	case rewardsdata.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case rewardsdata.FieldLastReward:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReward(v)
		return nil
	case rewardsdata.FieldFirstEra:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstEra(v)
		return nil
	case rewardsdata.FieldLastEra:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEra(v)
		return nil
	case rewardsdata.FieldFirstEraTimestamp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstEraTimestamp(v)
		return nil
	case rewardsdata.FieldLastEraTimestamp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEraTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown RewardsData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RewardsDataMutation) AddedFields() []string {
	var fields []string
	if m.addfirst_era != nil {
		fields = append(fields, rewardsdata.FieldFirstEra)
	}
	if m.addlast_era != nil {
		fields = append(fields, rewardsdata.FieldLastEra)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RewardsDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rewardsdata.FieldFirstEra:
		return m.AddedFirstEra()
	case rewardsdata.FieldLastEra:
		return m.AddedLastEra()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RewardsDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rewardsdata.FieldFirstEra:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstEra(v)
		return nil
	case rewardsdata.FieldLastEra:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastEra(v)
		return nil
	}
	return fmt.Errorf("unknown RewardsData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RewardsDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RewardsDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RewardsDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RewardsData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RewardsDataMutation) ResetField(name string) error {
	switch name {
	case rewardsdata.FieldValidator:
		m.ResetValidator()
		return nil
	case rewardsdata.FieldAmount:
		m.ResetAmount()
		return nil
	case rewardsdata.FieldLastReward:
		m.ResetLastReward()
		return nil
	case rewardsdata.FieldFirstEra:
		m.ResetFirstEra()
		return nil
	case rewardsdata.FieldLastEra:
		m.ResetLastEra()
		return nil
	case rewardsdata.FieldFirstEraTimestamp:
		m.ResetFirstEraTimestamp()
		return nil
	case rewardsdata.FieldLastEraTimestamp:
		m.ResetLastEraTimestamp()
		return nil
	}
	return fmt.Errorf("unknown RewardsData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RewardsDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, rewardsdata.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RewardsDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rewardsdata.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RewardsDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RewardsDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RewardsDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, rewardsdata.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RewardsDataMutation) EdgeCleared(name string) bool {
	switch name {
	case rewardsdata.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RewardsDataMutation) ClearEdge(name string) error {
	switch name {
	case rewardsdata.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown RewardsData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RewardsDataMutation) ResetEdge(name string) error {
	switch name {
	case rewardsdata.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown RewardsData edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	last_scanned_block_notificator    *int64
	addlast_scanned_block_notificator *int64
	last_scanned_era_validators       *int64
	addlast_scanned_era_validators    *int64
	clearedFields                     map[string]struct{}
	done                              bool
	oldValue                          func(context.Context) (*Settings, error)
	predicates                        []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastScannedBlockNotificator sets the "last_scanned_block_notificator" field.
func (m *SettingsMutation) SetLastScannedBlockNotificator(i int64) {
	m.last_scanned_block_notificator = &i
	m.addlast_scanned_block_notificator = nil
}

// LastScannedBlockNotificator returns the value of the "last_scanned_block_notificator" field in the mutation.
func (m *SettingsMutation) LastScannedBlockNotificator() (r int64, exists bool) {
	v := m.last_scanned_block_notificator
	if v == nil {
		return
	}
	return *v, true
}

// OldLastScannedBlockNotificator returns the old "last_scanned_block_notificator" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldLastScannedBlockNotificator(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastScannedBlockNotificator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastScannedBlockNotificator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastScannedBlockNotificator: %w", err)
	}
	return oldValue.LastScannedBlockNotificator, nil
}

// AddLastScannedBlockNotificator adds i to the "last_scanned_block_notificator" field.
func (m *SettingsMutation) AddLastScannedBlockNotificator(i int64) {
	if m.addlast_scanned_block_notificator != nil {
		*m.addlast_scanned_block_notificator += i
	} else {
		m.addlast_scanned_block_notificator = &i
	}
}

// AddedLastScannedBlockNotificator returns the value that was added to the "last_scanned_block_notificator" field in this mutation.
func (m *SettingsMutation) AddedLastScannedBlockNotificator() (r int64, exists bool) {
	v := m.addlast_scanned_block_notificator
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastScannedBlockNotificator clears the value of the "last_scanned_block_notificator" field.
func (m *SettingsMutation) ClearLastScannedBlockNotificator() {
	m.last_scanned_block_notificator = nil
	m.addlast_scanned_block_notificator = nil
	m.clearedFields[settings.FieldLastScannedBlockNotificator] = struct{}{}
}

// LastScannedBlockNotificatorCleared returns if the "last_scanned_block_notificator" field was cleared in this mutation.
func (m *SettingsMutation) LastScannedBlockNotificatorCleared() bool {
	_, ok := m.clearedFields[settings.FieldLastScannedBlockNotificator]
	return ok
}

// ResetLastScannedBlockNotificator resets all changes to the "last_scanned_block_notificator" field.
func (m *SettingsMutation) ResetLastScannedBlockNotificator() {
	m.last_scanned_block_notificator = nil
	m.addlast_scanned_block_notificator = nil
	delete(m.clearedFields, settings.FieldLastScannedBlockNotificator)
}

// SetLastScannedEraValidators sets the "last_scanned_era_validators" field.
func (m *SettingsMutation) SetLastScannedEraValidators(i int64) {
	m.last_scanned_era_validators = &i
	m.addlast_scanned_era_validators = nil
}

// LastScannedEraValidators returns the value of the "last_scanned_era_validators" field in the mutation.
func (m *SettingsMutation) LastScannedEraValidators() (r int64, exists bool) {
	v := m.last_scanned_era_validators
	if v == nil {
		return
	}
	return *v, true
}

// OldLastScannedEraValidators returns the old "last_scanned_era_validators" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldLastScannedEraValidators(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastScannedEraValidators is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastScannedEraValidators requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastScannedEraValidators: %w", err)
	}
	return oldValue.LastScannedEraValidators, nil
}

// AddLastScannedEraValidators adds i to the "last_scanned_era_validators" field.
func (m *SettingsMutation) AddLastScannedEraValidators(i int64) {
	if m.addlast_scanned_era_validators != nil {
		*m.addlast_scanned_era_validators += i
	} else {
		m.addlast_scanned_era_validators = &i
	}
}

// AddedLastScannedEraValidators returns the value that was added to the "last_scanned_era_validators" field in this mutation.
func (m *SettingsMutation) AddedLastScannedEraValidators() (r int64, exists bool) {
	v := m.addlast_scanned_era_validators
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastScannedEraValidators clears the value of the "last_scanned_era_validators" field.
func (m *SettingsMutation) ClearLastScannedEraValidators() {
	m.last_scanned_era_validators = nil
	m.addlast_scanned_era_validators = nil
	m.clearedFields[settings.FieldLastScannedEraValidators] = struct{}{}
}

// LastScannedEraValidatorsCleared returns if the "last_scanned_era_validators" field was cleared in this mutation.
func (m *SettingsMutation) LastScannedEraValidatorsCleared() bool {
	_, ok := m.clearedFields[settings.FieldLastScannedEraValidators]
	return ok
}

// ResetLastScannedEraValidators resets all changes to the "last_scanned_era_validators" field.
func (m *SettingsMutation) ResetLastScannedEraValidators() {
	m.last_scanned_era_validators = nil
	m.addlast_scanned_era_validators = nil
	delete(m.clearedFields, settings.FieldLastScannedEraValidators)
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.last_scanned_block_notificator != nil {
		fields = append(fields, settings.FieldLastScannedBlockNotificator)
	}
	if m.last_scanned_era_validators != nil {
		fields = append(fields, settings.FieldLastScannedEraValidators)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldLastScannedBlockNotificator:
		return m.LastScannedBlockNotificator()
	case settings.FieldLastScannedEraValidators:
		return m.LastScannedEraValidators()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldLastScannedBlockNotificator:
		return m.OldLastScannedBlockNotificator(ctx)
	case settings.FieldLastScannedEraValidators:
		return m.OldLastScannedEraValidators(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldLastScannedBlockNotificator:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastScannedBlockNotificator(v)
		return nil
	case settings.FieldLastScannedEraValidators:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastScannedEraValidators(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	var fields []string
	if m.addlast_scanned_block_notificator != nil {
		fields = append(fields, settings.FieldLastScannedBlockNotificator)
	}
	if m.addlast_scanned_era_validators != nil {
		fields = append(fields, settings.FieldLastScannedEraValidators)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldLastScannedBlockNotificator:
		return m.AddedLastScannedBlockNotificator()
	case settings.FieldLastScannedEraValidators:
		return m.AddedLastScannedEraValidators()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settings.FieldLastScannedBlockNotificator:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastScannedBlockNotificator(v)
		return nil
	case settings.FieldLastScannedEraValidators:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastScannedEraValidators(v)
		return nil
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settings.FieldLastScannedBlockNotificator) {
		fields = append(fields, settings.FieldLastScannedBlockNotificator)
	}
	if m.FieldCleared(settings.FieldLastScannedEraValidators) {
		fields = append(fields, settings.FieldLastScannedEraValidators)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	switch name {
	case settings.FieldLastScannedBlockNotificator:
		m.ClearLastScannedBlockNotificator()
		return nil
	case settings.FieldLastScannedEraValidators:
		m.ClearLastScannedEraValidators()
		return nil
	}
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldLastScannedBlockNotificator:
		m.ResetLastScannedBlockNotificator()
		return nil
	case settings.FieldLastScannedEraValidators:
		m.ResetLastScannedEraValidators()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Settings edge %s", name)
}

// SwapsMutation represents an operation that mutates the Swaps nodes in the graph.
type SwapsMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_type          *string
	to_address     *string
	from_currency  *string
	to_currency    *string
	to_network     *string
	from_network   *string
	amount         *string
	amountRecive   *string
	refund_address *string
	swap_id        *string
	extra_id       *string
	invoiceID      *int64
	addinvoiceID   *int64
	clearedFields  map[string]struct{}
	owner          *int64
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*Swaps, error)
	predicates     []predicate.Swaps
}

var _ ent.Mutation = (*SwapsMutation)(nil)

// swapsOption allows management of the mutation configuration using functional options.
type swapsOption func(*SwapsMutation)

// newSwapsMutation creates new mutation for the Swaps entity.
func newSwapsMutation(c config, op Op, opts ...swapsOption) *SwapsMutation {
	m := &SwapsMutation{
		config:        c,
		op:            op,
		typ:           TypeSwaps,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSwapsID sets the ID field of the mutation.
func withSwapsID(id int) swapsOption {
	return func(m *SwapsMutation) {
		var (
			err   error
			once  sync.Once
			value *Swaps
		)
		m.oldValue = func(ctx context.Context) (*Swaps, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Swaps.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSwaps sets the old Swaps of the mutation.
func withSwaps(node *Swaps) swapsOption {
	return func(m *SwapsMutation) {
		m.oldValue = func(context.Context) (*Swaps, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SwapsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SwapsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SwapsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SwapsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Swaps.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *SwapsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SwapsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *SwapsMutation) ClearType() {
	m._type = nil
	m.clearedFields[swaps.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *SwapsMutation) TypeCleared() bool {
	_, ok := m.clearedFields[swaps.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *SwapsMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, swaps.FieldType)
}

// SetToAddress sets the "to_address" field.
func (m *SwapsMutation) SetToAddress(s string) {
	m.to_address = &s
}

// ToAddress returns the value of the "to_address" field in the mutation.
func (m *SwapsMutation) ToAddress() (r string, exists bool) {
	v := m.to_address
	if v == nil {
		return
	}
	return *v, true
}

// OldToAddress returns the old "to_address" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldToAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAddress: %w", err)
	}
	return oldValue.ToAddress, nil
}

// ClearToAddress clears the value of the "to_address" field.
func (m *SwapsMutation) ClearToAddress() {
	m.to_address = nil
	m.clearedFields[swaps.FieldToAddress] = struct{}{}
}

// ToAddressCleared returns if the "to_address" field was cleared in this mutation.
func (m *SwapsMutation) ToAddressCleared() bool {
	_, ok := m.clearedFields[swaps.FieldToAddress]
	return ok
}

// ResetToAddress resets all changes to the "to_address" field.
func (m *SwapsMutation) ResetToAddress() {
	m.to_address = nil
	delete(m.clearedFields, swaps.FieldToAddress)
}

// SetFromCurrency sets the "from_currency" field.
func (m *SwapsMutation) SetFromCurrency(s string) {
	m.from_currency = &s
}

// FromCurrency returns the value of the "from_currency" field in the mutation.
func (m *SwapsMutation) FromCurrency() (r string, exists bool) {
	v := m.from_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldFromCurrency returns the old "from_currency" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldFromCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromCurrency: %w", err)
	}
	return oldValue.FromCurrency, nil
}

// ClearFromCurrency clears the value of the "from_currency" field.
func (m *SwapsMutation) ClearFromCurrency() {
	m.from_currency = nil
	m.clearedFields[swaps.FieldFromCurrency] = struct{}{}
}

// FromCurrencyCleared returns if the "from_currency" field was cleared in this mutation.
func (m *SwapsMutation) FromCurrencyCleared() bool {
	_, ok := m.clearedFields[swaps.FieldFromCurrency]
	return ok
}

// ResetFromCurrency resets all changes to the "from_currency" field.
func (m *SwapsMutation) ResetFromCurrency() {
	m.from_currency = nil
	delete(m.clearedFields, swaps.FieldFromCurrency)
}

// SetToCurrency sets the "to_currency" field.
func (m *SwapsMutation) SetToCurrency(s string) {
	m.to_currency = &s
}

// ToCurrency returns the value of the "to_currency" field in the mutation.
func (m *SwapsMutation) ToCurrency() (r string, exists bool) {
	v := m.to_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldToCurrency returns the old "to_currency" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldToCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToCurrency: %w", err)
	}
	return oldValue.ToCurrency, nil
}

// ClearToCurrency clears the value of the "to_currency" field.
func (m *SwapsMutation) ClearToCurrency() {
	m.to_currency = nil
	m.clearedFields[swaps.FieldToCurrency] = struct{}{}
}

// ToCurrencyCleared returns if the "to_currency" field was cleared in this mutation.
func (m *SwapsMutation) ToCurrencyCleared() bool {
	_, ok := m.clearedFields[swaps.FieldToCurrency]
	return ok
}

// ResetToCurrency resets all changes to the "to_currency" field.
func (m *SwapsMutation) ResetToCurrency() {
	m.to_currency = nil
	delete(m.clearedFields, swaps.FieldToCurrency)
}

// SetToNetwork sets the "to_network" field.
func (m *SwapsMutation) SetToNetwork(s string) {
	m.to_network = &s
}

// ToNetwork returns the value of the "to_network" field in the mutation.
func (m *SwapsMutation) ToNetwork() (r string, exists bool) {
	v := m.to_network
	if v == nil {
		return
	}
	return *v, true
}

// OldToNetwork returns the old "to_network" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldToNetwork(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToNetwork: %w", err)
	}
	return oldValue.ToNetwork, nil
}

// ClearToNetwork clears the value of the "to_network" field.
func (m *SwapsMutation) ClearToNetwork() {
	m.to_network = nil
	m.clearedFields[swaps.FieldToNetwork] = struct{}{}
}

// ToNetworkCleared returns if the "to_network" field was cleared in this mutation.
func (m *SwapsMutation) ToNetworkCleared() bool {
	_, ok := m.clearedFields[swaps.FieldToNetwork]
	return ok
}

// ResetToNetwork resets all changes to the "to_network" field.
func (m *SwapsMutation) ResetToNetwork() {
	m.to_network = nil
	delete(m.clearedFields, swaps.FieldToNetwork)
}

// SetFromNetwork sets the "from_network" field.
func (m *SwapsMutation) SetFromNetwork(s string) {
	m.from_network = &s
}

// FromNetwork returns the value of the "from_network" field in the mutation.
func (m *SwapsMutation) FromNetwork() (r string, exists bool) {
	v := m.from_network
	if v == nil {
		return
	}
	return *v, true
}

// OldFromNetwork returns the old "from_network" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldFromNetwork(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromNetwork: %w", err)
	}
	return oldValue.FromNetwork, nil
}

// ClearFromNetwork clears the value of the "from_network" field.
func (m *SwapsMutation) ClearFromNetwork() {
	m.from_network = nil
	m.clearedFields[swaps.FieldFromNetwork] = struct{}{}
}

// FromNetworkCleared returns if the "from_network" field was cleared in this mutation.
func (m *SwapsMutation) FromNetworkCleared() bool {
	_, ok := m.clearedFields[swaps.FieldFromNetwork]
	return ok
}

// ResetFromNetwork resets all changes to the "from_network" field.
func (m *SwapsMutation) ResetFromNetwork() {
	m.from_network = nil
	delete(m.clearedFields, swaps.FieldFromNetwork)
}

// SetAmount sets the "amount" field.
func (m *SwapsMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *SwapsMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *SwapsMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[swaps.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *SwapsMutation) AmountCleared() bool {
	_, ok := m.clearedFields[swaps.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *SwapsMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, swaps.FieldAmount)
}

// SetAmountRecive sets the "amountRecive" field.
func (m *SwapsMutation) SetAmountRecive(s string) {
	m.amountRecive = &s
}

// AmountRecive returns the value of the "amountRecive" field in the mutation.
func (m *SwapsMutation) AmountRecive() (r string, exists bool) {
	v := m.amountRecive
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountRecive returns the old "amountRecive" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldAmountRecive(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountRecive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountRecive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountRecive: %w", err)
	}
	return oldValue.AmountRecive, nil
}

// ClearAmountRecive clears the value of the "amountRecive" field.
func (m *SwapsMutation) ClearAmountRecive() {
	m.amountRecive = nil
	m.clearedFields[swaps.FieldAmountRecive] = struct{}{}
}

// AmountReciveCleared returns if the "amountRecive" field was cleared in this mutation.
func (m *SwapsMutation) AmountReciveCleared() bool {
	_, ok := m.clearedFields[swaps.FieldAmountRecive]
	return ok
}

// ResetAmountRecive resets all changes to the "amountRecive" field.
func (m *SwapsMutation) ResetAmountRecive() {
	m.amountRecive = nil
	delete(m.clearedFields, swaps.FieldAmountRecive)
}

// SetRefundAddress sets the "refund_address" field.
func (m *SwapsMutation) SetRefundAddress(s string) {
	m.refund_address = &s
}

// RefundAddress returns the value of the "refund_address" field in the mutation.
func (m *SwapsMutation) RefundAddress() (r string, exists bool) {
	v := m.refund_address
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAddress returns the old "refund_address" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldRefundAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAddress: %w", err)
	}
	return oldValue.RefundAddress, nil
}

// ClearRefundAddress clears the value of the "refund_address" field.
func (m *SwapsMutation) ClearRefundAddress() {
	m.refund_address = nil
	m.clearedFields[swaps.FieldRefundAddress] = struct{}{}
}

// RefundAddressCleared returns if the "refund_address" field was cleared in this mutation.
func (m *SwapsMutation) RefundAddressCleared() bool {
	_, ok := m.clearedFields[swaps.FieldRefundAddress]
	return ok
}

// ResetRefundAddress resets all changes to the "refund_address" field.
func (m *SwapsMutation) ResetRefundAddress() {
	m.refund_address = nil
	delete(m.clearedFields, swaps.FieldRefundAddress)
}

// SetSwapID sets the "swap_id" field.
func (m *SwapsMutation) SetSwapID(s string) {
	m.swap_id = &s
}

// SwapID returns the value of the "swap_id" field in the mutation.
func (m *SwapsMutation) SwapID() (r string, exists bool) {
	v := m.swap_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSwapID returns the old "swap_id" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldSwapID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSwapID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSwapID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSwapID: %w", err)
	}
	return oldValue.SwapID, nil
}

// ClearSwapID clears the value of the "swap_id" field.
func (m *SwapsMutation) ClearSwapID() {
	m.swap_id = nil
	m.clearedFields[swaps.FieldSwapID] = struct{}{}
}

// SwapIDCleared returns if the "swap_id" field was cleared in this mutation.
func (m *SwapsMutation) SwapIDCleared() bool {
	_, ok := m.clearedFields[swaps.FieldSwapID]
	return ok
}

// ResetSwapID resets all changes to the "swap_id" field.
func (m *SwapsMutation) ResetSwapID() {
	m.swap_id = nil
	delete(m.clearedFields, swaps.FieldSwapID)
}

// SetExtraID sets the "extra_id" field.
func (m *SwapsMutation) SetExtraID(s string) {
	m.extra_id = &s
}

// ExtraID returns the value of the "extra_id" field in the mutation.
func (m *SwapsMutation) ExtraID() (r string, exists bool) {
	v := m.extra_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraID returns the old "extra_id" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldExtraID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraID: %w", err)
	}
	return oldValue.ExtraID, nil
}

// ClearExtraID clears the value of the "extra_id" field.
func (m *SwapsMutation) ClearExtraID() {
	m.extra_id = nil
	m.clearedFields[swaps.FieldExtraID] = struct{}{}
}

// ExtraIDCleared returns if the "extra_id" field was cleared in this mutation.
func (m *SwapsMutation) ExtraIDCleared() bool {
	_, ok := m.clearedFields[swaps.FieldExtraID]
	return ok
}

// ResetExtraID resets all changes to the "extra_id" field.
func (m *SwapsMutation) ResetExtraID() {
	m.extra_id = nil
	delete(m.clearedFields, swaps.FieldExtraID)
}

// SetInvoiceID sets the "invoiceID" field.
func (m *SwapsMutation) SetInvoiceID(i int64) {
	m.invoiceID = &i
	m.addinvoiceID = nil
}

// InvoiceID returns the value of the "invoiceID" field in the mutation.
func (m *SwapsMutation) InvoiceID() (r int64, exists bool) {
	v := m.invoiceID
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoiceID" field's value of the Swaps entity.
// If the Swaps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapsMutation) OldInvoiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// AddInvoiceID adds i to the "invoiceID" field.
func (m *SwapsMutation) AddInvoiceID(i int64) {
	if m.addinvoiceID != nil {
		*m.addinvoiceID += i
	} else {
		m.addinvoiceID = &i
	}
}

// AddedInvoiceID returns the value that was added to the "invoiceID" field in this mutation.
func (m *SwapsMutation) AddedInvoiceID() (r int64, exists bool) {
	v := m.addinvoiceID
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvoiceID clears the value of the "invoiceID" field.
func (m *SwapsMutation) ClearInvoiceID() {
	m.invoiceID = nil
	m.addinvoiceID = nil
	m.clearedFields[swaps.FieldInvoiceID] = struct{}{}
}

// InvoiceIDCleared returns if the "invoiceID" field was cleared in this mutation.
func (m *SwapsMutation) InvoiceIDCleared() bool {
	_, ok := m.clearedFields[swaps.FieldInvoiceID]
	return ok
}

// ResetInvoiceID resets all changes to the "invoiceID" field.
func (m *SwapsMutation) ResetInvoiceID() {
	m.invoiceID = nil
	m.addinvoiceID = nil
	delete(m.clearedFields, swaps.FieldInvoiceID)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *SwapsMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *SwapsMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *SwapsMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SwapsMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SwapsMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SwapsMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SwapsMutation builder.
func (m *SwapsMutation) Where(ps ...predicate.Swaps) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SwapsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SwapsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Swaps, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SwapsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SwapsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Swaps).
func (m *SwapsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SwapsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._type != nil {
		fields = append(fields, swaps.FieldType)
	}
	if m.to_address != nil {
		fields = append(fields, swaps.FieldToAddress)
	}
	if m.from_currency != nil {
		fields = append(fields, swaps.FieldFromCurrency)
	}
	if m.to_currency != nil {
		fields = append(fields, swaps.FieldToCurrency)
	}
	if m.to_network != nil {
		fields = append(fields, swaps.FieldToNetwork)
	}
	if m.from_network != nil {
		fields = append(fields, swaps.FieldFromNetwork)
	}
	if m.amount != nil {
		fields = append(fields, swaps.FieldAmount)
	}
	if m.amountRecive != nil {
		fields = append(fields, swaps.FieldAmountRecive)
	}
	if m.refund_address != nil {
		fields = append(fields, swaps.FieldRefundAddress)
	}
	if m.swap_id != nil {
		fields = append(fields, swaps.FieldSwapID)
	}
	if m.extra_id != nil {
		fields = append(fields, swaps.FieldExtraID)
	}
	if m.invoiceID != nil {
		fields = append(fields, swaps.FieldInvoiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SwapsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case swaps.FieldType:
		return m.GetType()
	case swaps.FieldToAddress:
		return m.ToAddress()
	case swaps.FieldFromCurrency:
		return m.FromCurrency()
	case swaps.FieldToCurrency:
		return m.ToCurrency()
	case swaps.FieldToNetwork:
		return m.ToNetwork()
	case swaps.FieldFromNetwork:
		return m.FromNetwork()
	case swaps.FieldAmount:
		return m.Amount()
	case swaps.FieldAmountRecive:
		return m.AmountRecive()
	case swaps.FieldRefundAddress:
		return m.RefundAddress()
	case swaps.FieldSwapID:
		return m.SwapID()
	case swaps.FieldExtraID:
		return m.ExtraID()
	case swaps.FieldInvoiceID:
		return m.InvoiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SwapsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case swaps.FieldType:
		return m.OldType(ctx)
	case swaps.FieldToAddress:
		return m.OldToAddress(ctx)
	case swaps.FieldFromCurrency:
		return m.OldFromCurrency(ctx)
	case swaps.FieldToCurrency:
		return m.OldToCurrency(ctx)
	case swaps.FieldToNetwork:
		return m.OldToNetwork(ctx)
	case swaps.FieldFromNetwork:
		return m.OldFromNetwork(ctx)
	case swaps.FieldAmount:
		return m.OldAmount(ctx)
	case swaps.FieldAmountRecive:
		return m.OldAmountRecive(ctx)
	case swaps.FieldRefundAddress:
		return m.OldRefundAddress(ctx)
	case swaps.FieldSwapID:
		return m.OldSwapID(ctx)
	case swaps.FieldExtraID:
		return m.OldExtraID(ctx)
	case swaps.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	}
	return nil, fmt.Errorf("unknown Swaps field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SwapsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case swaps.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case swaps.FieldToAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAddress(v)
		return nil
	case swaps.FieldFromCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromCurrency(v)
		return nil
	case swaps.FieldToCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToCurrency(v)
		return nil
	case swaps.FieldToNetwork:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToNetwork(v)
		return nil
	case swaps.FieldFromNetwork:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromNetwork(v)
		return nil
	case swaps.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case swaps.FieldAmountRecive:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountRecive(v)
		return nil
	case swaps.FieldRefundAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAddress(v)
		return nil
	case swaps.FieldSwapID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSwapID(v)
		return nil
	case swaps.FieldExtraID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraID(v)
		return nil
	case swaps.FieldInvoiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Swaps field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SwapsMutation) AddedFields() []string {
	var fields []string
	if m.addinvoiceID != nil {
		fields = append(fields, swaps.FieldInvoiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SwapsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case swaps.FieldInvoiceID:
		return m.AddedInvoiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SwapsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case swaps.FieldInvoiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Swaps numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SwapsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(swaps.FieldType) {
		fields = append(fields, swaps.FieldType)
	}
	if m.FieldCleared(swaps.FieldToAddress) {
		fields = append(fields, swaps.FieldToAddress)
	}
	if m.FieldCleared(swaps.FieldFromCurrency) {
		fields = append(fields, swaps.FieldFromCurrency)
	}
	if m.FieldCleared(swaps.FieldToCurrency) {
		fields = append(fields, swaps.FieldToCurrency)
	}
	if m.FieldCleared(swaps.FieldToNetwork) {
		fields = append(fields, swaps.FieldToNetwork)
	}
	if m.FieldCleared(swaps.FieldFromNetwork) {
		fields = append(fields, swaps.FieldFromNetwork)
	}
	if m.FieldCleared(swaps.FieldAmount) {
		fields = append(fields, swaps.FieldAmount)
	}
	if m.FieldCleared(swaps.FieldAmountRecive) {
		fields = append(fields, swaps.FieldAmountRecive)
	}
	if m.FieldCleared(swaps.FieldRefundAddress) {
		fields = append(fields, swaps.FieldRefundAddress)
	}
	if m.FieldCleared(swaps.FieldSwapID) {
		fields = append(fields, swaps.FieldSwapID)
	}
	if m.FieldCleared(swaps.FieldExtraID) {
		fields = append(fields, swaps.FieldExtraID)
	}
	if m.FieldCleared(swaps.FieldInvoiceID) {
		fields = append(fields, swaps.FieldInvoiceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SwapsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SwapsMutation) ClearField(name string) error {
	switch name {
	case swaps.FieldType:
		m.ClearType()
		return nil
	case swaps.FieldToAddress:
		m.ClearToAddress()
		return nil
	case swaps.FieldFromCurrency:
		m.ClearFromCurrency()
		return nil
	case swaps.FieldToCurrency:
		m.ClearToCurrency()
		return nil
	case swaps.FieldToNetwork:
		m.ClearToNetwork()
		return nil
	case swaps.FieldFromNetwork:
		m.ClearFromNetwork()
		return nil
	case swaps.FieldAmount:
		m.ClearAmount()
		return nil
	case swaps.FieldAmountRecive:
		m.ClearAmountRecive()
		return nil
	case swaps.FieldRefundAddress:
		m.ClearRefundAddress()
		return nil
	case swaps.FieldSwapID:
		m.ClearSwapID()
		return nil
	case swaps.FieldExtraID:
		m.ClearExtraID()
		return nil
	case swaps.FieldInvoiceID:
		m.ClearInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown Swaps nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SwapsMutation) ResetField(name string) error {
	switch name {
	case swaps.FieldType:
		m.ResetType()
		return nil
	case swaps.FieldToAddress:
		m.ResetToAddress()
		return nil
	case swaps.FieldFromCurrency:
		m.ResetFromCurrency()
		return nil
	case swaps.FieldToCurrency:
		m.ResetToCurrency()
		return nil
	case swaps.FieldToNetwork:
		m.ResetToNetwork()
		return nil
	case swaps.FieldFromNetwork:
		m.ResetFromNetwork()
		return nil
	case swaps.FieldAmount:
		m.ResetAmount()
		return nil
	case swaps.FieldAmountRecive:
		m.ResetAmountRecive()
		return nil
	case swaps.FieldRefundAddress:
		m.ResetRefundAddress()
		return nil
	case swaps.FieldSwapID:
		m.ResetSwapID()
		return nil
	case swaps.FieldExtraID:
		m.ResetExtraID()
		return nil
	case swaps.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown Swaps field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SwapsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, swaps.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SwapsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case swaps.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SwapsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SwapsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SwapsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, swaps.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SwapsMutation) EdgeCleared(name string) bool {
	switch name {
	case swaps.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SwapsMutation) ClearEdge(name string) error {
	switch name {
	case swaps.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Swaps unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SwapsMutation) ResetEdge(name string) error {
	switch name {
	case swaps.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Swaps edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	created_at    *time.Time
	data          *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Task, error)
	predicates    []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetData sets the "data" field.
func (m *TaskMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *TaskMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *TaskMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.data != nil {
		fields = append(fields, task.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldName:
		return m.Name()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}

// TransfersMutation represents an operation that mutates the Transfers nodes in the graph.
type TransfersMutation struct {
	config
	op              Op
	typ             string
	id              *int
	from_pubkey     *string
	to_pubkey       *string
	name            *string
	sender_balance  *string
	amount          *string
	memo_id         *uint64
	addmemo_id      *int64
	created_at      *time.Time
	status          *string
	_Deploy         *string
	_AdditionalType *string
	invoiceID       *int64
	addinvoiceID    *int64
	clearedFields   map[string]struct{}
	owner           *int64
	clearedowner    bool
	done            bool
	oldValue        func(context.Context) (*Transfers, error)
	predicates      []predicate.Transfers
}

var _ ent.Mutation = (*TransfersMutation)(nil)

// transfersOption allows management of the mutation configuration using functional options.
type transfersOption func(*TransfersMutation)

// newTransfersMutation creates new mutation for the Transfers entity.
func newTransfersMutation(c config, op Op, opts ...transfersOption) *TransfersMutation {
	m := &TransfersMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransfersID sets the ID field of the mutation.
func withTransfersID(id int) transfersOption {
	return func(m *TransfersMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfers
		)
		m.oldValue = func(ctx context.Context) (*Transfers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfers sets the old Transfers of the mutation.
func withTransfers(node *Transfers) transfersOption {
	return func(m *TransfersMutation) {
		m.oldValue = func(context.Context) (*Transfers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransfersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransfersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransfersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransfersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromPubkey sets the "from_pubkey" field.
func (m *TransfersMutation) SetFromPubkey(s string) {
	m.from_pubkey = &s
}

// FromPubkey returns the value of the "from_pubkey" field in the mutation.
func (m *TransfersMutation) FromPubkey() (r string, exists bool) {
	v := m.from_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldFromPubkey returns the old "from_pubkey" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldFromPubkey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromPubkey: %w", err)
	}
	return oldValue.FromPubkey, nil
}

// ResetFromPubkey resets all changes to the "from_pubkey" field.
func (m *TransfersMutation) ResetFromPubkey() {
	m.from_pubkey = nil
}

// SetToPubkey sets the "to_pubkey" field.
func (m *TransfersMutation) SetToPubkey(s string) {
	m.to_pubkey = &s
}

// ToPubkey returns the value of the "to_pubkey" field in the mutation.
func (m *TransfersMutation) ToPubkey() (r string, exists bool) {
	v := m.to_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldToPubkey returns the old "to_pubkey" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldToPubkey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToPubkey: %w", err)
	}
	return oldValue.ToPubkey, nil
}

// ClearToPubkey clears the value of the "to_pubkey" field.
func (m *TransfersMutation) ClearToPubkey() {
	m.to_pubkey = nil
	m.clearedFields[transfers.FieldToPubkey] = struct{}{}
}

// ToPubkeyCleared returns if the "to_pubkey" field was cleared in this mutation.
func (m *TransfersMutation) ToPubkeyCleared() bool {
	_, ok := m.clearedFields[transfers.FieldToPubkey]
	return ok
}

// ResetToPubkey resets all changes to the "to_pubkey" field.
func (m *TransfersMutation) ResetToPubkey() {
	m.to_pubkey = nil
	delete(m.clearedFields, transfers.FieldToPubkey)
}

// SetName sets the "name" field.
func (m *TransfersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TransfersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TransfersMutation) ClearName() {
	m.name = nil
	m.clearedFields[transfers.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TransfersMutation) NameCleared() bool {
	_, ok := m.clearedFields[transfers.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TransfersMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, transfers.FieldName)
}

// SetSenderBalance sets the "sender_balance" field.
func (m *TransfersMutation) SetSenderBalance(s string) {
	m.sender_balance = &s
}

// SenderBalance returns the value of the "sender_balance" field in the mutation.
func (m *TransfersMutation) SenderBalance() (r string, exists bool) {
	v := m.sender_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderBalance returns the old "sender_balance" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldSenderBalance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderBalance: %w", err)
	}
	return oldValue.SenderBalance, nil
}

// ClearSenderBalance clears the value of the "sender_balance" field.
func (m *TransfersMutation) ClearSenderBalance() {
	m.sender_balance = nil
	m.clearedFields[transfers.FieldSenderBalance] = struct{}{}
}

// SenderBalanceCleared returns if the "sender_balance" field was cleared in this mutation.
func (m *TransfersMutation) SenderBalanceCleared() bool {
	_, ok := m.clearedFields[transfers.FieldSenderBalance]
	return ok
}

// ResetSenderBalance resets all changes to the "sender_balance" field.
func (m *TransfersMutation) ResetSenderBalance() {
	m.sender_balance = nil
	delete(m.clearedFields, transfers.FieldSenderBalance)
}

// SetAmount sets the "amount" field.
func (m *TransfersMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransfersMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *TransfersMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[transfers.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *TransfersMutation) AmountCleared() bool {
	_, ok := m.clearedFields[transfers.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransfersMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, transfers.FieldAmount)
}

// SetMemoID sets the "memo_id" field.
func (m *TransfersMutation) SetMemoID(u uint64) {
	m.memo_id = &u
	m.addmemo_id = nil
}

// MemoID returns the value of the "memo_id" field in the mutation.
func (m *TransfersMutation) MemoID() (r uint64, exists bool) {
	v := m.memo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoID returns the old "memo_id" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldMemoID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoID: %w", err)
	}
	return oldValue.MemoID, nil
}

// AddMemoID adds u to the "memo_id" field.
func (m *TransfersMutation) AddMemoID(u int64) {
	if m.addmemo_id != nil {
		*m.addmemo_id += u
	} else {
		m.addmemo_id = &u
	}
}

// AddedMemoID returns the value that was added to the "memo_id" field in this mutation.
func (m *TransfersMutation) AddedMemoID() (r int64, exists bool) {
	v := m.addmemo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemoID clears the value of the "memo_id" field.
func (m *TransfersMutation) ClearMemoID() {
	m.memo_id = nil
	m.addmemo_id = nil
	m.clearedFields[transfers.FieldMemoID] = struct{}{}
}

// MemoIDCleared returns if the "memo_id" field was cleared in this mutation.
func (m *TransfersMutation) MemoIDCleared() bool {
	_, ok := m.clearedFields[transfers.FieldMemoID]
	return ok
}

// ResetMemoID resets all changes to the "memo_id" field.
func (m *TransfersMutation) ResetMemoID() {
	m.memo_id = nil
	m.addmemo_id = nil
	delete(m.clearedFields, transfers.FieldMemoID)
}

// SetCreatedAt sets the "created_at" field.
func (m *TransfersMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransfersMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TransfersMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[transfers.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TransfersMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[transfers.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransfersMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, transfers.FieldCreatedAt)
}

// SetStatus sets the "status" field.
func (m *TransfersMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TransfersMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TransfersMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[transfers.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TransfersMutation) StatusCleared() bool {
	_, ok := m.clearedFields[transfers.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TransfersMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, transfers.FieldStatus)
}

// SetDeploy sets the "Deploy" field.
func (m *TransfersMutation) SetDeploy(s string) {
	m._Deploy = &s
}

// Deploy returns the value of the "Deploy" field in the mutation.
func (m *TransfersMutation) Deploy() (r string, exists bool) {
	v := m._Deploy
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploy returns the old "Deploy" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldDeploy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploy: %w", err)
	}
	return oldValue.Deploy, nil
}

// ClearDeploy clears the value of the "Deploy" field.
func (m *TransfersMutation) ClearDeploy() {
	m._Deploy = nil
	m.clearedFields[transfers.FieldDeploy] = struct{}{}
}

// DeployCleared returns if the "Deploy" field was cleared in this mutation.
func (m *TransfersMutation) DeployCleared() bool {
	_, ok := m.clearedFields[transfers.FieldDeploy]
	return ok
}

// ResetDeploy resets all changes to the "Deploy" field.
func (m *TransfersMutation) ResetDeploy() {
	m._Deploy = nil
	delete(m.clearedFields, transfers.FieldDeploy)
}

// SetAdditionalType sets the "AdditionalType" field.
func (m *TransfersMutation) SetAdditionalType(s string) {
	m._AdditionalType = &s
}

// AdditionalType returns the value of the "AdditionalType" field in the mutation.
func (m *TransfersMutation) AdditionalType() (r string, exists bool) {
	v := m._AdditionalType
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalType returns the old "AdditionalType" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldAdditionalType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalType: %w", err)
	}
	return oldValue.AdditionalType, nil
}

// ClearAdditionalType clears the value of the "AdditionalType" field.
func (m *TransfersMutation) ClearAdditionalType() {
	m._AdditionalType = nil
	m.clearedFields[transfers.FieldAdditionalType] = struct{}{}
}

// AdditionalTypeCleared returns if the "AdditionalType" field was cleared in this mutation.
func (m *TransfersMutation) AdditionalTypeCleared() bool {
	_, ok := m.clearedFields[transfers.FieldAdditionalType]
	return ok
}

// ResetAdditionalType resets all changes to the "AdditionalType" field.
func (m *TransfersMutation) ResetAdditionalType() {
	m._AdditionalType = nil
	delete(m.clearedFields, transfers.FieldAdditionalType)
}

// SetInvoiceID sets the "invoiceID" field.
func (m *TransfersMutation) SetInvoiceID(i int64) {
	m.invoiceID = &i
	m.addinvoiceID = nil
}

// InvoiceID returns the value of the "invoiceID" field in the mutation.
func (m *TransfersMutation) InvoiceID() (r int64, exists bool) {
	v := m.invoiceID
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoiceID" field's value of the Transfers entity.
// If the Transfers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransfersMutation) OldInvoiceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// AddInvoiceID adds i to the "invoiceID" field.
func (m *TransfersMutation) AddInvoiceID(i int64) {
	if m.addinvoiceID != nil {
		*m.addinvoiceID += i
	} else {
		m.addinvoiceID = &i
	}
}

// AddedInvoiceID returns the value that was added to the "invoiceID" field in this mutation.
func (m *TransfersMutation) AddedInvoiceID() (r int64, exists bool) {
	v := m.addinvoiceID
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvoiceID clears the value of the "invoiceID" field.
func (m *TransfersMutation) ClearInvoiceID() {
	m.invoiceID = nil
	m.addinvoiceID = nil
	m.clearedFields[transfers.FieldInvoiceID] = struct{}{}
}

// InvoiceIDCleared returns if the "invoiceID" field was cleared in this mutation.
func (m *TransfersMutation) InvoiceIDCleared() bool {
	_, ok := m.clearedFields[transfers.FieldInvoiceID]
	return ok
}

// ResetInvoiceID resets all changes to the "invoiceID" field.
func (m *TransfersMutation) ResetInvoiceID() {
	m.invoiceID = nil
	m.addinvoiceID = nil
	delete(m.clearedFields, transfers.FieldInvoiceID)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TransfersMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TransfersMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TransfersMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TransfersMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TransfersMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TransfersMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TransfersMutation builder.
func (m *TransfersMutation) Where(ps ...predicate.Transfers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransfersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransfersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transfers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransfersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransfersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transfers).
func (m *TransfersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransfersMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.from_pubkey != nil {
		fields = append(fields, transfers.FieldFromPubkey)
	}
	if m.to_pubkey != nil {
		fields = append(fields, transfers.FieldToPubkey)
	}
	if m.name != nil {
		fields = append(fields, transfers.FieldName)
	}
	if m.sender_balance != nil {
		fields = append(fields, transfers.FieldSenderBalance)
	}
	if m.amount != nil {
		fields = append(fields, transfers.FieldAmount)
	}
	if m.memo_id != nil {
		fields = append(fields, transfers.FieldMemoID)
	}
	if m.created_at != nil {
		fields = append(fields, transfers.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, transfers.FieldStatus)
	}
	if m._Deploy != nil {
		fields = append(fields, transfers.FieldDeploy)
	}
	if m._AdditionalType != nil {
		fields = append(fields, transfers.FieldAdditionalType)
	}
	if m.invoiceID != nil {
		fields = append(fields, transfers.FieldInvoiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransfersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfers.FieldFromPubkey:
		return m.FromPubkey()
	case transfers.FieldToPubkey:
		return m.ToPubkey()
	case transfers.FieldName:
		return m.Name()
	case transfers.FieldSenderBalance:
		return m.SenderBalance()
	case transfers.FieldAmount:
		return m.Amount()
	case transfers.FieldMemoID:
		return m.MemoID()
	case transfers.FieldCreatedAt:
		return m.CreatedAt()
	case transfers.FieldStatus:
		return m.Status()
	case transfers.FieldDeploy:
		return m.Deploy()
	case transfers.FieldAdditionalType:
		return m.AdditionalType()
	case transfers.FieldInvoiceID:
		return m.InvoiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransfersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfers.FieldFromPubkey:
		return m.OldFromPubkey(ctx)
	case transfers.FieldToPubkey:
		return m.OldToPubkey(ctx)
	case transfers.FieldName:
		return m.OldName(ctx)
	case transfers.FieldSenderBalance:
		return m.OldSenderBalance(ctx)
	case transfers.FieldAmount:
		return m.OldAmount(ctx)
	case transfers.FieldMemoID:
		return m.OldMemoID(ctx)
	case transfers.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transfers.FieldStatus:
		return m.OldStatus(ctx)
	case transfers.FieldDeploy:
		return m.OldDeploy(ctx)
	case transfers.FieldAdditionalType:
		return m.OldAdditionalType(ctx)
	case transfers.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	}
	return nil, fmt.Errorf("unknown Transfers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransfersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfers.FieldFromPubkey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromPubkey(v)
		return nil
	case transfers.FieldToPubkey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToPubkey(v)
		return nil
	case transfers.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transfers.FieldSenderBalance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderBalance(v)
		return nil
	case transfers.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transfers.FieldMemoID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoID(v)
		return nil
	case transfers.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transfers.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transfers.FieldDeploy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploy(v)
		return nil
	case transfers.FieldAdditionalType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalType(v)
		return nil
	case transfers.FieldInvoiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Transfers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransfersMutation) AddedFields() []string {
	var fields []string
	if m.addmemo_id != nil {
		fields = append(fields, transfers.FieldMemoID)
	}
	if m.addinvoiceID != nil {
		fields = append(fields, transfers.FieldInvoiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransfersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfers.FieldMemoID:
		return m.AddedMemoID()
	case transfers.FieldInvoiceID:
		return m.AddedInvoiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransfersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfers.FieldMemoID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoID(v)
		return nil
	case transfers.FieldInvoiceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Transfers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransfersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transfers.FieldToPubkey) {
		fields = append(fields, transfers.FieldToPubkey)
	}
	if m.FieldCleared(transfers.FieldName) {
		fields = append(fields, transfers.FieldName)
	}
	if m.FieldCleared(transfers.FieldSenderBalance) {
		fields = append(fields, transfers.FieldSenderBalance)
	}
	if m.FieldCleared(transfers.FieldAmount) {
		fields = append(fields, transfers.FieldAmount)
	}
	if m.FieldCleared(transfers.FieldMemoID) {
		fields = append(fields, transfers.FieldMemoID)
	}
	if m.FieldCleared(transfers.FieldCreatedAt) {
		fields = append(fields, transfers.FieldCreatedAt)
	}
	if m.FieldCleared(transfers.FieldStatus) {
		fields = append(fields, transfers.FieldStatus)
	}
	if m.FieldCleared(transfers.FieldDeploy) {
		fields = append(fields, transfers.FieldDeploy)
	}
	if m.FieldCleared(transfers.FieldAdditionalType) {
		fields = append(fields, transfers.FieldAdditionalType)
	}
	if m.FieldCleared(transfers.FieldInvoiceID) {
		fields = append(fields, transfers.FieldInvoiceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransfersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransfersMutation) ClearField(name string) error {
	switch name {
	case transfers.FieldToPubkey:
		m.ClearToPubkey()
		return nil
	case transfers.FieldName:
		m.ClearName()
		return nil
	case transfers.FieldSenderBalance:
		m.ClearSenderBalance()
		return nil
	case transfers.FieldAmount:
		m.ClearAmount()
		return nil
	case transfers.FieldMemoID:
		m.ClearMemoID()
		return nil
	case transfers.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case transfers.FieldStatus:
		m.ClearStatus()
		return nil
	case transfers.FieldDeploy:
		m.ClearDeploy()
		return nil
	case transfers.FieldAdditionalType:
		m.ClearAdditionalType()
		return nil
	case transfers.FieldInvoiceID:
		m.ClearInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown Transfers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransfersMutation) ResetField(name string) error {
	switch name {
	case transfers.FieldFromPubkey:
		m.ResetFromPubkey()
		return nil
	case transfers.FieldToPubkey:
		m.ResetToPubkey()
		return nil
	case transfers.FieldName:
		m.ResetName()
		return nil
	case transfers.FieldSenderBalance:
		m.ResetSenderBalance()
		return nil
	case transfers.FieldAmount:
		m.ResetAmount()
		return nil
	case transfers.FieldMemoID:
		m.ResetMemoID()
		return nil
	case transfers.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transfers.FieldStatus:
		m.ResetStatus()
		return nil
	case transfers.FieldDeploy:
		m.ResetDeploy()
		return nil
	case transfers.FieldAdditionalType:
		m.ResetAdditionalType()
		return nil
	case transfers.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	}
	return fmt.Errorf("unknown Transfers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransfersMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, transfers.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransfersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfers.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransfersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransfersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransfersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, transfers.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransfersMutation) EdgeCleared(name string) bool {
	switch name {
	case transfers.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransfersMutation) ClearEdge(name string) error {
	switch name {
	case transfers.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Transfers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransfersMutation) ResetEdge(name string) error {
	switch name {
	case transfers.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Transfers edge %s", name)
}

// UndelegatesMutation represents an operation that mutates the Undelegates nodes in the graph.
type UndelegatesMutation struct {
	config
	op             Op
	typ            string
	id             *int
	delegator      *string
	validator      *string
	name           *string
	staked_balance *string
	amount         *string
	created_at     *time.Time
	status         *string
	_Deploy        *string
	clearedFields  map[string]struct{}
	owner          *int64
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*Undelegates, error)
	predicates     []predicate.Undelegates
}

var _ ent.Mutation = (*UndelegatesMutation)(nil)

// undelegatesOption allows management of the mutation configuration using functional options.
type undelegatesOption func(*UndelegatesMutation)

// newUndelegatesMutation creates new mutation for the Undelegates entity.
func newUndelegatesMutation(c config, op Op, opts ...undelegatesOption) *UndelegatesMutation {
	m := &UndelegatesMutation{
		config:        c,
		op:            op,
		typ:           TypeUndelegates,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUndelegatesID sets the ID field of the mutation.
func withUndelegatesID(id int) undelegatesOption {
	return func(m *UndelegatesMutation) {
		var (
			err   error
			once  sync.Once
			value *Undelegates
		)
		m.oldValue = func(ctx context.Context) (*Undelegates, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Undelegates.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUndelegates sets the old Undelegates of the mutation.
func withUndelegates(node *Undelegates) undelegatesOption {
	return func(m *UndelegatesMutation) {
		m.oldValue = func(context.Context) (*Undelegates, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UndelegatesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UndelegatesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UndelegatesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UndelegatesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Undelegates.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDelegator sets the "delegator" field.
func (m *UndelegatesMutation) SetDelegator(s string) {
	m.delegator = &s
}

// Delegator returns the value of the "delegator" field in the mutation.
func (m *UndelegatesMutation) Delegator() (r string, exists bool) {
	v := m.delegator
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegator returns the old "delegator" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldDelegator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegator: %w", err)
	}
	return oldValue.Delegator, nil
}

// ResetDelegator resets all changes to the "delegator" field.
func (m *UndelegatesMutation) ResetDelegator() {
	m.delegator = nil
}

// SetValidator sets the "validator" field.
func (m *UndelegatesMutation) SetValidator(s string) {
	m.validator = &s
}

// Validator returns the value of the "validator" field in the mutation.
func (m *UndelegatesMutation) Validator() (r string, exists bool) {
	v := m.validator
	if v == nil {
		return
	}
	return *v, true
}

// OldValidator returns the old "validator" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldValidator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidator: %w", err)
	}
	return oldValue.Validator, nil
}

// ClearValidator clears the value of the "validator" field.
func (m *UndelegatesMutation) ClearValidator() {
	m.validator = nil
	m.clearedFields[undelegates.FieldValidator] = struct{}{}
}

// ValidatorCleared returns if the "validator" field was cleared in this mutation.
func (m *UndelegatesMutation) ValidatorCleared() bool {
	_, ok := m.clearedFields[undelegates.FieldValidator]
	return ok
}

// ResetValidator resets all changes to the "validator" field.
func (m *UndelegatesMutation) ResetValidator() {
	m.validator = nil
	delete(m.clearedFields, undelegates.FieldValidator)
}

// SetName sets the "name" field.
func (m *UndelegatesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UndelegatesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UndelegatesMutation) ClearName() {
	m.name = nil
	m.clearedFields[undelegates.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UndelegatesMutation) NameCleared() bool {
	_, ok := m.clearedFields[undelegates.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UndelegatesMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, undelegates.FieldName)
}

// SetStakedBalance sets the "staked_balance" field.
func (m *UndelegatesMutation) SetStakedBalance(s string) {
	m.staked_balance = &s
}

// StakedBalance returns the value of the "staked_balance" field in the mutation.
func (m *UndelegatesMutation) StakedBalance() (r string, exists bool) {
	v := m.staked_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldStakedBalance returns the old "staked_balance" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldStakedBalance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStakedBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStakedBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStakedBalance: %w", err)
	}
	return oldValue.StakedBalance, nil
}

// ClearStakedBalance clears the value of the "staked_balance" field.
func (m *UndelegatesMutation) ClearStakedBalance() {
	m.staked_balance = nil
	m.clearedFields[undelegates.FieldStakedBalance] = struct{}{}
}

// StakedBalanceCleared returns if the "staked_balance" field was cleared in this mutation.
func (m *UndelegatesMutation) StakedBalanceCleared() bool {
	_, ok := m.clearedFields[undelegates.FieldStakedBalance]
	return ok
}

// ResetStakedBalance resets all changes to the "staked_balance" field.
func (m *UndelegatesMutation) ResetStakedBalance() {
	m.staked_balance = nil
	delete(m.clearedFields, undelegates.FieldStakedBalance)
}

// SetAmount sets the "amount" field.
func (m *UndelegatesMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *UndelegatesMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *UndelegatesMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[undelegates.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *UndelegatesMutation) AmountCleared() bool {
	_, ok := m.clearedFields[undelegates.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *UndelegatesMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, undelegates.FieldAmount)
}

// SetCreatedAt sets the "created_at" field.
func (m *UndelegatesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UndelegatesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UndelegatesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[undelegates.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UndelegatesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[undelegates.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UndelegatesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, undelegates.FieldCreatedAt)
}

// SetStatus sets the "status" field.
func (m *UndelegatesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UndelegatesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UndelegatesMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[undelegates.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UndelegatesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[undelegates.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UndelegatesMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, undelegates.FieldStatus)
}

// SetDeploy sets the "Deploy" field.
func (m *UndelegatesMutation) SetDeploy(s string) {
	m._Deploy = &s
}

// Deploy returns the value of the "Deploy" field in the mutation.
func (m *UndelegatesMutation) Deploy() (r string, exists bool) {
	v := m._Deploy
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploy returns the old "Deploy" field's value of the Undelegates entity.
// If the Undelegates object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UndelegatesMutation) OldDeploy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploy: %w", err)
	}
	return oldValue.Deploy, nil
}

// ClearDeploy clears the value of the "Deploy" field.
func (m *UndelegatesMutation) ClearDeploy() {
	m._Deploy = nil
	m.clearedFields[undelegates.FieldDeploy] = struct{}{}
}

// DeployCleared returns if the "Deploy" field was cleared in this mutation.
func (m *UndelegatesMutation) DeployCleared() bool {
	_, ok := m.clearedFields[undelegates.FieldDeploy]
	return ok
}

// ResetDeploy resets all changes to the "Deploy" field.
func (m *UndelegatesMutation) ResetDeploy() {
	m._Deploy = nil
	delete(m.clearedFields, undelegates.FieldDeploy)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *UndelegatesMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *UndelegatesMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *UndelegatesMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UndelegatesMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UndelegatesMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UndelegatesMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UndelegatesMutation builder.
func (m *UndelegatesMutation) Where(ps ...predicate.Undelegates) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UndelegatesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UndelegatesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Undelegates, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UndelegatesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UndelegatesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Undelegates).
func (m *UndelegatesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UndelegatesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.delegator != nil {
		fields = append(fields, undelegates.FieldDelegator)
	}
	if m.validator != nil {
		fields = append(fields, undelegates.FieldValidator)
	}
	if m.name != nil {
		fields = append(fields, undelegates.FieldName)
	}
	if m.staked_balance != nil {
		fields = append(fields, undelegates.FieldStakedBalance)
	}
	if m.amount != nil {
		fields = append(fields, undelegates.FieldAmount)
	}
	if m.created_at != nil {
		fields = append(fields, undelegates.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, undelegates.FieldStatus)
	}
	if m._Deploy != nil {
		fields = append(fields, undelegates.FieldDeploy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UndelegatesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case undelegates.FieldDelegator:
		return m.Delegator()
	case undelegates.FieldValidator:
		return m.Validator()
	case undelegates.FieldName:
		return m.Name()
	case undelegates.FieldStakedBalance:
		return m.StakedBalance()
	case undelegates.FieldAmount:
		return m.Amount()
	case undelegates.FieldCreatedAt:
		return m.CreatedAt()
	case undelegates.FieldStatus:
		return m.Status()
	case undelegates.FieldDeploy:
		return m.Deploy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UndelegatesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case undelegates.FieldDelegator:
		return m.OldDelegator(ctx)
	case undelegates.FieldValidator:
		return m.OldValidator(ctx)
	case undelegates.FieldName:
		return m.OldName(ctx)
	case undelegates.FieldStakedBalance:
		return m.OldStakedBalance(ctx)
	case undelegates.FieldAmount:
		return m.OldAmount(ctx)
	case undelegates.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case undelegates.FieldStatus:
		return m.OldStatus(ctx)
	case undelegates.FieldDeploy:
		return m.OldDeploy(ctx)
	}
	return nil, fmt.Errorf("unknown Undelegates field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UndelegatesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case undelegates.FieldDelegator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegator(v)
		return nil
	case undelegates.FieldValidator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidator(v)
		return nil
	case undelegates.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case undelegates.FieldStakedBalance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStakedBalance(v)
		return nil
	case undelegates.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case undelegates.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case undelegates.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case undelegates.FieldDeploy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploy(v)
		return nil
	}
	return fmt.Errorf("unknown Undelegates field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UndelegatesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UndelegatesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UndelegatesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Undelegates numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UndelegatesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(undelegates.FieldValidator) {
		fields = append(fields, undelegates.FieldValidator)
	}
	if m.FieldCleared(undelegates.FieldName) {
		fields = append(fields, undelegates.FieldName)
	}
	if m.FieldCleared(undelegates.FieldStakedBalance) {
		fields = append(fields, undelegates.FieldStakedBalance)
	}
	if m.FieldCleared(undelegates.FieldAmount) {
		fields = append(fields, undelegates.FieldAmount)
	}
	if m.FieldCleared(undelegates.FieldCreatedAt) {
		fields = append(fields, undelegates.FieldCreatedAt)
	}
	if m.FieldCleared(undelegates.FieldStatus) {
		fields = append(fields, undelegates.FieldStatus)
	}
	if m.FieldCleared(undelegates.FieldDeploy) {
		fields = append(fields, undelegates.FieldDeploy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UndelegatesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UndelegatesMutation) ClearField(name string) error {
	switch name {
	case undelegates.FieldValidator:
		m.ClearValidator()
		return nil
	case undelegates.FieldName:
		m.ClearName()
		return nil
	case undelegates.FieldStakedBalance:
		m.ClearStakedBalance()
		return nil
	case undelegates.FieldAmount:
		m.ClearAmount()
		return nil
	case undelegates.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case undelegates.FieldStatus:
		m.ClearStatus()
		return nil
	case undelegates.FieldDeploy:
		m.ClearDeploy()
		return nil
	}
	return fmt.Errorf("unknown Undelegates nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UndelegatesMutation) ResetField(name string) error {
	switch name {
	case undelegates.FieldDelegator:
		m.ResetDelegator()
		return nil
	case undelegates.FieldValidator:
		m.ResetValidator()
		return nil
	case undelegates.FieldName:
		m.ResetName()
		return nil
	case undelegates.FieldStakedBalance:
		m.ResetStakedBalance()
		return nil
	case undelegates.FieldAmount:
		m.ResetAmount()
		return nil
	case undelegates.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case undelegates.FieldStatus:
		m.ResetStatus()
		return nil
	case undelegates.FieldDeploy:
		m.ResetDeploy()
		return nil
	}
	return fmt.Errorf("unknown Undelegates field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UndelegatesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, undelegates.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UndelegatesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case undelegates.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UndelegatesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UndelegatesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UndelegatesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, undelegates.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UndelegatesMutation) EdgeCleared(name string) bool {
	switch name {
	case undelegates.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UndelegatesMutation) ClearEdge(name string) error {
	switch name {
	case undelegates.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Undelegates unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UndelegatesMutation) ResetEdge(name string) error {
	switch name {
	case undelegates.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Undelegates edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	public_key            *string
	password              *string
	logged_in             *bool
	last_access           *time.Time
	lock_timeout          *int64
	addlock_timeout       *int64
	locked_manual         *bool
	notify                *bool
	notify_time           *int8
	addnotify_time        *int8
	notify_last_time      *time.Time
	store_privat_key      *bool
	enable_logging        *bool
	registered            *bool
	clearedFields         map[string]struct{}
	balance               *int
	clearedbalance        bool
	address_book          map[int]struct{}
	removedaddress_book   map[int]struct{}
	clearedaddress_book   bool
	state                 *int
	clearedstate          bool
	rewards_data          map[int]struct{}
	removedrewards_data   map[int]struct{}
	clearedrewards_data   bool
	_PrivateKey           *int
	cleared_PrivateKey    bool
	transfers             map[int]struct{}
	removedtransfers      map[int]struct{}
	clearedtransfers      bool
	delegates             map[int]struct{}
	removeddelegates      map[int]struct{}
	cleareddelegates      bool
	undelegates           map[int]struct{}
	removedundelegates    map[int]struct{}
	clearedundelegates    bool
	swaps                 map[int]struct{}
	removedswaps          map[int]struct{}
	clearedswaps          bool
	invoices              map[int]struct{}
	removedinvoices       map[int]struct{}
	clearedinvoices       bool
	recentInvoices        map[int]struct{}
	removedrecentInvoices map[int]struct{}
	clearedrecentInvoices bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublicKey sets the "public_key" field.
func (m *UserMutation) SetPublicKey(s string) {
	m.public_key = &s
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *UserMutation) PublicKey() (r string, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ClearPublicKey clears the value of the "public_key" field.
func (m *UserMutation) ClearPublicKey() {
	m.public_key = nil
	m.clearedFields[user.FieldPublicKey] = struct{}{}
}

// PublicKeyCleared returns if the "public_key" field was cleared in this mutation.
func (m *UserMutation) PublicKeyCleared() bool {
	_, ok := m.clearedFields[user.FieldPublicKey]
	return ok
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *UserMutation) ResetPublicKey() {
	m.public_key = nil
	delete(m.clearedFields, user.FieldPublicKey)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetLoggedIn sets the "logged_in" field.
func (m *UserMutation) SetLoggedIn(b bool) {
	m.logged_in = &b
}

// LoggedIn returns the value of the "logged_in" field in the mutation.
func (m *UserMutation) LoggedIn() (r bool, exists bool) {
	v := m.logged_in
	if v == nil {
		return
	}
	return *v, true
}

// OldLoggedIn returns the old "logged_in" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoggedIn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoggedIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoggedIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoggedIn: %w", err)
	}
	return oldValue.LoggedIn, nil
}

// ResetLoggedIn resets all changes to the "logged_in" field.
func (m *UserMutation) ResetLoggedIn() {
	m.logged_in = nil
}

// SetLastAccess sets the "last_access" field.
func (m *UserMutation) SetLastAccess(t time.Time) {
	m.last_access = &t
}

// LastAccess returns the value of the "last_access" field in the mutation.
func (m *UserMutation) LastAccess() (r time.Time, exists bool) {
	v := m.last_access
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccess returns the old "last_access" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastAccess(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccess: %w", err)
	}
	return oldValue.LastAccess, nil
}

// ClearLastAccess clears the value of the "last_access" field.
func (m *UserMutation) ClearLastAccess() {
	m.last_access = nil
	m.clearedFields[user.FieldLastAccess] = struct{}{}
}

// LastAccessCleared returns if the "last_access" field was cleared in this mutation.
func (m *UserMutation) LastAccessCleared() bool {
	_, ok := m.clearedFields[user.FieldLastAccess]
	return ok
}

// ResetLastAccess resets all changes to the "last_access" field.
func (m *UserMutation) ResetLastAccess() {
	m.last_access = nil
	delete(m.clearedFields, user.FieldLastAccess)
}

// SetLockTimeout sets the "lock_timeout" field.
func (m *UserMutation) SetLockTimeout(i int64) {
	m.lock_timeout = &i
	m.addlock_timeout = nil
}

// LockTimeout returns the value of the "lock_timeout" field in the mutation.
func (m *UserMutation) LockTimeout() (r int64, exists bool) {
	v := m.lock_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldLockTimeout returns the old "lock_timeout" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockTimeout(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockTimeout: %w", err)
	}
	return oldValue.LockTimeout, nil
}

// AddLockTimeout adds i to the "lock_timeout" field.
func (m *UserMutation) AddLockTimeout(i int64) {
	if m.addlock_timeout != nil {
		*m.addlock_timeout += i
	} else {
		m.addlock_timeout = &i
	}
}

// AddedLockTimeout returns the value that was added to the "lock_timeout" field in this mutation.
func (m *UserMutation) AddedLockTimeout() (r int64, exists bool) {
	v := m.addlock_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearLockTimeout clears the value of the "lock_timeout" field.
func (m *UserMutation) ClearLockTimeout() {
	m.lock_timeout = nil
	m.addlock_timeout = nil
	m.clearedFields[user.FieldLockTimeout] = struct{}{}
}

// LockTimeoutCleared returns if the "lock_timeout" field was cleared in this mutation.
func (m *UserMutation) LockTimeoutCleared() bool {
	_, ok := m.clearedFields[user.FieldLockTimeout]
	return ok
}

// ResetLockTimeout resets all changes to the "lock_timeout" field.
func (m *UserMutation) ResetLockTimeout() {
	m.lock_timeout = nil
	m.addlock_timeout = nil
	delete(m.clearedFields, user.FieldLockTimeout)
}

// SetLockedManual sets the "locked_manual" field.
func (m *UserMutation) SetLockedManual(b bool) {
	m.locked_manual = &b
}

// LockedManual returns the value of the "locked_manual" field in the mutation.
func (m *UserMutation) LockedManual() (r bool, exists bool) {
	v := m.locked_manual
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedManual returns the old "locked_manual" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockedManual(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedManual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedManual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedManual: %w", err)
	}
	return oldValue.LockedManual, nil
}

// ClearLockedManual clears the value of the "locked_manual" field.
func (m *UserMutation) ClearLockedManual() {
	m.locked_manual = nil
	m.clearedFields[user.FieldLockedManual] = struct{}{}
}

// LockedManualCleared returns if the "locked_manual" field was cleared in this mutation.
func (m *UserMutation) LockedManualCleared() bool {
	_, ok := m.clearedFields[user.FieldLockedManual]
	return ok
}

// ResetLockedManual resets all changes to the "locked_manual" field.
func (m *UserMutation) ResetLockedManual() {
	m.locked_manual = nil
	delete(m.clearedFields, user.FieldLockedManual)
}

// SetNotify sets the "notify" field.
func (m *UserMutation) SetNotify(b bool) {
	m.notify = &b
}

// Notify returns the value of the "notify" field in the mutation.
func (m *UserMutation) Notify() (r bool, exists bool) {
	v := m.notify
	if v == nil {
		return
	}
	return *v, true
}

// OldNotify returns the old "notify" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotify(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotify: %w", err)
	}
	return oldValue.Notify, nil
}

// ResetNotify resets all changes to the "notify" field.
func (m *UserMutation) ResetNotify() {
	m.notify = nil
}

// SetNotifyTime sets the "notify_time" field.
func (m *UserMutation) SetNotifyTime(i int8) {
	m.notify_time = &i
	m.addnotify_time = nil
}

// NotifyTime returns the value of the "notify_time" field in the mutation.
func (m *UserMutation) NotifyTime() (r int8, exists bool) {
	v := m.notify_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTime returns the old "notify_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotifyTime(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTime: %w", err)
	}
	return oldValue.NotifyTime, nil
}

// AddNotifyTime adds i to the "notify_time" field.
func (m *UserMutation) AddNotifyTime(i int8) {
	if m.addnotify_time != nil {
		*m.addnotify_time += i
	} else {
		m.addnotify_time = &i
	}
}

// AddedNotifyTime returns the value that was added to the "notify_time" field in this mutation.
func (m *UserMutation) AddedNotifyTime() (r int8, exists bool) {
	v := m.addnotify_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetNotifyTime resets all changes to the "notify_time" field.
func (m *UserMutation) ResetNotifyTime() {
	m.notify_time = nil
	m.addnotify_time = nil
}

// SetNotifyLastTime sets the "notify_last_time" field.
func (m *UserMutation) SetNotifyLastTime(t time.Time) {
	m.notify_last_time = &t
}

// NotifyLastTime returns the value of the "notify_last_time" field in the mutation.
func (m *UserMutation) NotifyLastTime() (r time.Time, exists bool) {
	v := m.notify_last_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyLastTime returns the old "notify_last_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotifyLastTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyLastTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyLastTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyLastTime: %w", err)
	}
	return oldValue.NotifyLastTime, nil
}

// ResetNotifyLastTime resets all changes to the "notify_last_time" field.
func (m *UserMutation) ResetNotifyLastTime() {
	m.notify_last_time = nil
}

// SetStorePrivatKey sets the "store_privat_key" field.
func (m *UserMutation) SetStorePrivatKey(b bool) {
	m.store_privat_key = &b
}

// StorePrivatKey returns the value of the "store_privat_key" field in the mutation.
func (m *UserMutation) StorePrivatKey() (r bool, exists bool) {
	v := m.store_privat_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStorePrivatKey returns the old "store_privat_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStorePrivatKey(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorePrivatKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorePrivatKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorePrivatKey: %w", err)
	}
	return oldValue.StorePrivatKey, nil
}

// ResetStorePrivatKey resets all changes to the "store_privat_key" field.
func (m *UserMutation) ResetStorePrivatKey() {
	m.store_privat_key = nil
}

// SetEnableLogging sets the "enable_logging" field.
func (m *UserMutation) SetEnableLogging(b bool) {
	m.enable_logging = &b
}

// EnableLogging returns the value of the "enable_logging" field in the mutation.
func (m *UserMutation) EnableLogging() (r bool, exists bool) {
	v := m.enable_logging
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableLogging returns the old "enable_logging" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEnableLogging(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableLogging is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableLogging requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableLogging: %w", err)
	}
	return oldValue.EnableLogging, nil
}

// ResetEnableLogging resets all changes to the "enable_logging" field.
func (m *UserMutation) ResetEnableLogging() {
	m.enable_logging = nil
}

// SetRegistered sets the "registered" field.
func (m *UserMutation) SetRegistered(b bool) {
	m.registered = &b
}

// Registered returns the value of the "registered" field in the mutation.
func (m *UserMutation) Registered() (r bool, exists bool) {
	v := m.registered
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistered returns the old "registered" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegistered(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistered: %w", err)
	}
	return oldValue.Registered, nil
}

// ResetRegistered resets all changes to the "registered" field.
func (m *UserMutation) ResetRegistered() {
	m.registered = nil
}

// SetBalanceID sets the "balance" edge to the Balances entity by id.
func (m *UserMutation) SetBalanceID(id int) {
	m.balance = &id
}

// ClearBalance clears the "balance" edge to the Balances entity.
func (m *UserMutation) ClearBalance() {
	m.clearedbalance = true
}

// BalanceCleared reports if the "balance" edge to the Balances entity was cleared.
func (m *UserMutation) BalanceCleared() bool {
	return m.clearedbalance
}

// BalanceID returns the "balance" edge ID in the mutation.
func (m *UserMutation) BalanceID() (id int, exists bool) {
	if m.balance != nil {
		return *m.balance, true
	}
	return
}

// BalanceIDs returns the "balance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BalanceID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BalanceIDs() (ids []int) {
	if id := m.balance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBalance resets all changes to the "balance" edge.
func (m *UserMutation) ResetBalance() {
	m.balance = nil
	m.clearedbalance = false
}

// AddAddressBookIDs adds the "address_book" edge to the AdressBook entity by ids.
func (m *UserMutation) AddAddressBookIDs(ids ...int) {
	if m.address_book == nil {
		m.address_book = make(map[int]struct{})
	}
	for i := range ids {
		m.address_book[ids[i]] = struct{}{}
	}
}

// ClearAddressBook clears the "address_book" edge to the AdressBook entity.
func (m *UserMutation) ClearAddressBook() {
	m.clearedaddress_book = true
}

// AddressBookCleared reports if the "address_book" edge to the AdressBook entity was cleared.
func (m *UserMutation) AddressBookCleared() bool {
	return m.clearedaddress_book
}

// RemoveAddressBookIDs removes the "address_book" edge to the AdressBook entity by IDs.
func (m *UserMutation) RemoveAddressBookIDs(ids ...int) {
	if m.removedaddress_book == nil {
		m.removedaddress_book = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.address_book, ids[i])
		m.removedaddress_book[ids[i]] = struct{}{}
	}
}

// RemovedAddressBook returns the removed IDs of the "address_book" edge to the AdressBook entity.
func (m *UserMutation) RemovedAddressBookIDs() (ids []int) {
	for id := range m.removedaddress_book {
		ids = append(ids, id)
	}
	return
}

// AddressBookIDs returns the "address_book" edge IDs in the mutation.
func (m *UserMutation) AddressBookIDs() (ids []int) {
	for id := range m.address_book {
		ids = append(ids, id)
	}
	return
}

// ResetAddressBook resets all changes to the "address_book" edge.
func (m *UserMutation) ResetAddressBook() {
	m.address_book = nil
	m.clearedaddress_book = false
	m.removedaddress_book = nil
}

// SetStateID sets the "state" edge to the UserState entity by id.
func (m *UserMutation) SetStateID(id int) {
	m.state = &id
}

// ClearState clears the "state" edge to the UserState entity.
func (m *UserMutation) ClearState() {
	m.clearedstate = true
}

// StateCleared reports if the "state" edge to the UserState entity was cleared.
func (m *UserMutation) StateCleared() bool {
	return m.clearedstate
}

// StateID returns the "state" edge ID in the mutation.
func (m *UserMutation) StateID() (id int, exists bool) {
	if m.state != nil {
		return *m.state, true
	}
	return
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StateIDs() (ids []int) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *UserMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// AddRewardsDatumIDs adds the "rewards_data" edge to the RewardsData entity by ids.
func (m *UserMutation) AddRewardsDatumIDs(ids ...int) {
	if m.rewards_data == nil {
		m.rewards_data = make(map[int]struct{})
	}
	for i := range ids {
		m.rewards_data[ids[i]] = struct{}{}
	}
}

// ClearRewardsData clears the "rewards_data" edge to the RewardsData entity.
func (m *UserMutation) ClearRewardsData() {
	m.clearedrewards_data = true
}

// RewardsDataCleared reports if the "rewards_data" edge to the RewardsData entity was cleared.
func (m *UserMutation) RewardsDataCleared() bool {
	return m.clearedrewards_data
}

// RemoveRewardsDatumIDs removes the "rewards_data" edge to the RewardsData entity by IDs.
func (m *UserMutation) RemoveRewardsDatumIDs(ids ...int) {
	if m.removedrewards_data == nil {
		m.removedrewards_data = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rewards_data, ids[i])
		m.removedrewards_data[ids[i]] = struct{}{}
	}
}

// RemovedRewardsData returns the removed IDs of the "rewards_data" edge to the RewardsData entity.
func (m *UserMutation) RemovedRewardsDataIDs() (ids []int) {
	for id := range m.removedrewards_data {
		ids = append(ids, id)
	}
	return
}

// RewardsDataIDs returns the "rewards_data" edge IDs in the mutation.
func (m *UserMutation) RewardsDataIDs() (ids []int) {
	for id := range m.rewards_data {
		ids = append(ids, id)
	}
	return
}

// ResetRewardsData resets all changes to the "rewards_data" edge.
func (m *UserMutation) ResetRewardsData() {
	m.rewards_data = nil
	m.clearedrewards_data = false
	m.removedrewards_data = nil
}

// SetPrivateKeyID sets the "PrivateKey" edge to the PrivateKeys entity by id.
func (m *UserMutation) SetPrivateKeyID(id int) {
	m._PrivateKey = &id
}

// ClearPrivateKey clears the "PrivateKey" edge to the PrivateKeys entity.
func (m *UserMutation) ClearPrivateKey() {
	m.cleared_PrivateKey = true
}

// PrivateKeyCleared reports if the "PrivateKey" edge to the PrivateKeys entity was cleared.
func (m *UserMutation) PrivateKeyCleared() bool {
	return m.cleared_PrivateKey
}

// PrivateKeyID returns the "PrivateKey" edge ID in the mutation.
func (m *UserMutation) PrivateKeyID() (id int, exists bool) {
	if m._PrivateKey != nil {
		return *m._PrivateKey, true
	}
	return
}

// PrivateKeyIDs returns the "PrivateKey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrivateKeyID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PrivateKeyIDs() (ids []int) {
	if id := m._PrivateKey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrivateKey resets all changes to the "PrivateKey" edge.
func (m *UserMutation) ResetPrivateKey() {
	m._PrivateKey = nil
	m.cleared_PrivateKey = false
}

// AddTransferIDs adds the "transfers" edge to the Transfers entity by ids.
func (m *UserMutation) AddTransferIDs(ids ...int) {
	if m.transfers == nil {
		m.transfers = make(map[int]struct{})
	}
	for i := range ids {
		m.transfers[ids[i]] = struct{}{}
	}
}

// ClearTransfers clears the "transfers" edge to the Transfers entity.
func (m *UserMutation) ClearTransfers() {
	m.clearedtransfers = true
}

// TransfersCleared reports if the "transfers" edge to the Transfers entity was cleared.
func (m *UserMutation) TransfersCleared() bool {
	return m.clearedtransfers
}

// RemoveTransferIDs removes the "transfers" edge to the Transfers entity by IDs.
func (m *UserMutation) RemoveTransferIDs(ids ...int) {
	if m.removedtransfers == nil {
		m.removedtransfers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transfers, ids[i])
		m.removedtransfers[ids[i]] = struct{}{}
	}
}

// RemovedTransfers returns the removed IDs of the "transfers" edge to the Transfers entity.
func (m *UserMutation) RemovedTransfersIDs() (ids []int) {
	for id := range m.removedtransfers {
		ids = append(ids, id)
	}
	return
}

// TransfersIDs returns the "transfers" edge IDs in the mutation.
func (m *UserMutation) TransfersIDs() (ids []int) {
	for id := range m.transfers {
		ids = append(ids, id)
	}
	return
}

// ResetTransfers resets all changes to the "transfers" edge.
func (m *UserMutation) ResetTransfers() {
	m.transfers = nil
	m.clearedtransfers = false
	m.removedtransfers = nil
}

// AddDelegateIDs adds the "delegates" edge to the Delegates entity by ids.
func (m *UserMutation) AddDelegateIDs(ids ...int) {
	if m.delegates == nil {
		m.delegates = make(map[int]struct{})
	}
	for i := range ids {
		m.delegates[ids[i]] = struct{}{}
	}
}

// ClearDelegates clears the "delegates" edge to the Delegates entity.
func (m *UserMutation) ClearDelegates() {
	m.cleareddelegates = true
}

// DelegatesCleared reports if the "delegates" edge to the Delegates entity was cleared.
func (m *UserMutation) DelegatesCleared() bool {
	return m.cleareddelegates
}

// RemoveDelegateIDs removes the "delegates" edge to the Delegates entity by IDs.
func (m *UserMutation) RemoveDelegateIDs(ids ...int) {
	if m.removeddelegates == nil {
		m.removeddelegates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.delegates, ids[i])
		m.removeddelegates[ids[i]] = struct{}{}
	}
}

// RemovedDelegates returns the removed IDs of the "delegates" edge to the Delegates entity.
func (m *UserMutation) RemovedDelegatesIDs() (ids []int) {
	for id := range m.removeddelegates {
		ids = append(ids, id)
	}
	return
}

// DelegatesIDs returns the "delegates" edge IDs in the mutation.
func (m *UserMutation) DelegatesIDs() (ids []int) {
	for id := range m.delegates {
		ids = append(ids, id)
	}
	return
}

// ResetDelegates resets all changes to the "delegates" edge.
func (m *UserMutation) ResetDelegates() {
	m.delegates = nil
	m.cleareddelegates = false
	m.removeddelegates = nil
}

// AddUndelegateIDs adds the "undelegates" edge to the Undelegates entity by ids.
func (m *UserMutation) AddUndelegateIDs(ids ...int) {
	if m.undelegates == nil {
		m.undelegates = make(map[int]struct{})
	}
	for i := range ids {
		m.undelegates[ids[i]] = struct{}{}
	}
}

// ClearUndelegates clears the "undelegates" edge to the Undelegates entity.
func (m *UserMutation) ClearUndelegates() {
	m.clearedundelegates = true
}

// UndelegatesCleared reports if the "undelegates" edge to the Undelegates entity was cleared.
func (m *UserMutation) UndelegatesCleared() bool {
	return m.clearedundelegates
}

// RemoveUndelegateIDs removes the "undelegates" edge to the Undelegates entity by IDs.
func (m *UserMutation) RemoveUndelegateIDs(ids ...int) {
	if m.removedundelegates == nil {
		m.removedundelegates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.undelegates, ids[i])
		m.removedundelegates[ids[i]] = struct{}{}
	}
}

// RemovedUndelegates returns the removed IDs of the "undelegates" edge to the Undelegates entity.
func (m *UserMutation) RemovedUndelegatesIDs() (ids []int) {
	for id := range m.removedundelegates {
		ids = append(ids, id)
	}
	return
}

// UndelegatesIDs returns the "undelegates" edge IDs in the mutation.
func (m *UserMutation) UndelegatesIDs() (ids []int) {
	for id := range m.undelegates {
		ids = append(ids, id)
	}
	return
}

// ResetUndelegates resets all changes to the "undelegates" edge.
func (m *UserMutation) ResetUndelegates() {
	m.undelegates = nil
	m.clearedundelegates = false
	m.removedundelegates = nil
}

// AddSwapIDs adds the "swaps" edge to the Swaps entity by ids.
func (m *UserMutation) AddSwapIDs(ids ...int) {
	if m.swaps == nil {
		m.swaps = make(map[int]struct{})
	}
	for i := range ids {
		m.swaps[ids[i]] = struct{}{}
	}
}

// ClearSwaps clears the "swaps" edge to the Swaps entity.
func (m *UserMutation) ClearSwaps() {
	m.clearedswaps = true
}

// SwapsCleared reports if the "swaps" edge to the Swaps entity was cleared.
func (m *UserMutation) SwapsCleared() bool {
	return m.clearedswaps
}

// RemoveSwapIDs removes the "swaps" edge to the Swaps entity by IDs.
func (m *UserMutation) RemoveSwapIDs(ids ...int) {
	if m.removedswaps == nil {
		m.removedswaps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.swaps, ids[i])
		m.removedswaps[ids[i]] = struct{}{}
	}
}

// RemovedSwaps returns the removed IDs of the "swaps" edge to the Swaps entity.
func (m *UserMutation) RemovedSwapsIDs() (ids []int) {
	for id := range m.removedswaps {
		ids = append(ids, id)
	}
	return
}

// SwapsIDs returns the "swaps" edge IDs in the mutation.
func (m *UserMutation) SwapsIDs() (ids []int) {
	for id := range m.swaps {
		ids = append(ids, id)
	}
	return
}

// ResetSwaps resets all changes to the "swaps" edge.
func (m *UserMutation) ResetSwaps() {
	m.swaps = nil
	m.clearedswaps = false
	m.removedswaps = nil
}

// AddInvoiceIDs adds the "invoices" edge to the Invoice entity by ids.
func (m *UserMutation) AddInvoiceIDs(ids ...int) {
	if m.invoices == nil {
		m.invoices = make(map[int]struct{})
	}
	for i := range ids {
		m.invoices[ids[i]] = struct{}{}
	}
}

// ClearInvoices clears the "invoices" edge to the Invoice entity.
func (m *UserMutation) ClearInvoices() {
	m.clearedinvoices = true
}

// InvoicesCleared reports if the "invoices" edge to the Invoice entity was cleared.
func (m *UserMutation) InvoicesCleared() bool {
	return m.clearedinvoices
}

// RemoveInvoiceIDs removes the "invoices" edge to the Invoice entity by IDs.
func (m *UserMutation) RemoveInvoiceIDs(ids ...int) {
	if m.removedinvoices == nil {
		m.removedinvoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invoices, ids[i])
		m.removedinvoices[ids[i]] = struct{}{}
	}
}

// RemovedInvoices returns the removed IDs of the "invoices" edge to the Invoice entity.
func (m *UserMutation) RemovedInvoicesIDs() (ids []int) {
	for id := range m.removedinvoices {
		ids = append(ids, id)
	}
	return
}

// InvoicesIDs returns the "invoices" edge IDs in the mutation.
func (m *UserMutation) InvoicesIDs() (ids []int) {
	for id := range m.invoices {
		ids = append(ids, id)
	}
	return
}

// ResetInvoices resets all changes to the "invoices" edge.
func (m *UserMutation) ResetInvoices() {
	m.invoices = nil
	m.clearedinvoices = false
	m.removedinvoices = nil
}

// AddRecentInvoiceIDs adds the "recentInvoices" edge to the RecentInvoices entity by ids.
func (m *UserMutation) AddRecentInvoiceIDs(ids ...int) {
	if m.recentInvoices == nil {
		m.recentInvoices = make(map[int]struct{})
	}
	for i := range ids {
		m.recentInvoices[ids[i]] = struct{}{}
	}
}

// ClearRecentInvoices clears the "recentInvoices" edge to the RecentInvoices entity.
func (m *UserMutation) ClearRecentInvoices() {
	m.clearedrecentInvoices = true
}

// RecentInvoicesCleared reports if the "recentInvoices" edge to the RecentInvoices entity was cleared.
func (m *UserMutation) RecentInvoicesCleared() bool {
	return m.clearedrecentInvoices
}

// RemoveRecentInvoiceIDs removes the "recentInvoices" edge to the RecentInvoices entity by IDs.
func (m *UserMutation) RemoveRecentInvoiceIDs(ids ...int) {
	if m.removedrecentInvoices == nil {
		m.removedrecentInvoices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.recentInvoices, ids[i])
		m.removedrecentInvoices[ids[i]] = struct{}{}
	}
}

// RemovedRecentInvoices returns the removed IDs of the "recentInvoices" edge to the RecentInvoices entity.
func (m *UserMutation) RemovedRecentInvoicesIDs() (ids []int) {
	for id := range m.removedrecentInvoices {
		ids = append(ids, id)
	}
	return
}

// RecentInvoicesIDs returns the "recentInvoices" edge IDs in the mutation.
func (m *UserMutation) RecentInvoicesIDs() (ids []int) {
	for id := range m.recentInvoices {
		ids = append(ids, id)
	}
	return
}

// ResetRecentInvoices resets all changes to the "recentInvoices" edge.
func (m *UserMutation) ResetRecentInvoices() {
	m.recentInvoices = nil
	m.clearedrecentInvoices = false
	m.removedrecentInvoices = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.public_key != nil {
		fields = append(fields, user.FieldPublicKey)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.logged_in != nil {
		fields = append(fields, user.FieldLoggedIn)
	}
	if m.last_access != nil {
		fields = append(fields, user.FieldLastAccess)
	}
	if m.lock_timeout != nil {
		fields = append(fields, user.FieldLockTimeout)
	}
	if m.locked_manual != nil {
		fields = append(fields, user.FieldLockedManual)
	}
	if m.notify != nil {
		fields = append(fields, user.FieldNotify)
	}
	if m.notify_time != nil {
		fields = append(fields, user.FieldNotifyTime)
	}
	if m.notify_last_time != nil {
		fields = append(fields, user.FieldNotifyLastTime)
	}
	if m.store_privat_key != nil {
		fields = append(fields, user.FieldStorePrivatKey)
	}
	if m.enable_logging != nil {
		fields = append(fields, user.FieldEnableLogging)
	}
	if m.registered != nil {
		fields = append(fields, user.FieldRegistered)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPublicKey:
		return m.PublicKey()
	case user.FieldPassword:
		return m.Password()
	case user.FieldLoggedIn:
		return m.LoggedIn()
	case user.FieldLastAccess:
		return m.LastAccess()
	case user.FieldLockTimeout:
		return m.LockTimeout()
	case user.FieldLockedManual:
		return m.LockedManual()
	case user.FieldNotify:
		return m.Notify()
	case user.FieldNotifyTime:
		return m.NotifyTime()
	case user.FieldNotifyLastTime:
		return m.NotifyLastTime()
	case user.FieldStorePrivatKey:
		return m.StorePrivatKey()
	case user.FieldEnableLogging:
		return m.EnableLogging()
	case user.FieldRegistered:
		return m.Registered()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldLoggedIn:
		return m.OldLoggedIn(ctx)
	case user.FieldLastAccess:
		return m.OldLastAccess(ctx)
	case user.FieldLockTimeout:
		return m.OldLockTimeout(ctx)
	case user.FieldLockedManual:
		return m.OldLockedManual(ctx)
	case user.FieldNotify:
		return m.OldNotify(ctx)
	case user.FieldNotifyTime:
		return m.OldNotifyTime(ctx)
	case user.FieldNotifyLastTime:
		return m.OldNotifyLastTime(ctx)
	case user.FieldStorePrivatKey:
		return m.OldStorePrivatKey(ctx)
	case user.FieldEnableLogging:
		return m.OldEnableLogging(ctx)
	case user.FieldRegistered:
		return m.OldRegistered(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldLoggedIn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoggedIn(v)
		return nil
	case user.FieldLastAccess:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccess(v)
		return nil
	case user.FieldLockTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockTimeout(v)
		return nil
	case user.FieldLockedManual:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedManual(v)
		return nil
	case user.FieldNotify:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotify(v)
		return nil
	case user.FieldNotifyTime:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTime(v)
		return nil
	case user.FieldNotifyLastTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyLastTime(v)
		return nil
	case user.FieldStorePrivatKey:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorePrivatKey(v)
		return nil
	case user.FieldEnableLogging:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableLogging(v)
		return nil
	case user.FieldRegistered:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistered(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addlock_timeout != nil {
		fields = append(fields, user.FieldLockTimeout)
	}
	if m.addnotify_time != nil {
		fields = append(fields, user.FieldNotifyTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLockTimeout:
		return m.AddedLockTimeout()
	case user.FieldNotifyTime:
		return m.AddedNotifyTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldLockTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLockTimeout(v)
		return nil
	case user.FieldNotifyTime:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyTime(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPublicKey) {
		fields = append(fields, user.FieldPublicKey)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldLastAccess) {
		fields = append(fields, user.FieldLastAccess)
	}
	if m.FieldCleared(user.FieldLockTimeout) {
		fields = append(fields, user.FieldLockTimeout)
	}
	if m.FieldCleared(user.FieldLockedManual) {
		fields = append(fields, user.FieldLockedManual)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPublicKey:
		m.ClearPublicKey()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldLastAccess:
		m.ClearLastAccess()
		return nil
	case user.FieldLockTimeout:
		m.ClearLockTimeout()
		return nil
	case user.FieldLockedManual:
		m.ClearLockedManual()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldLoggedIn:
		m.ResetLoggedIn()
		return nil
	case user.FieldLastAccess:
		m.ResetLastAccess()
		return nil
	case user.FieldLockTimeout:
		m.ResetLockTimeout()
		return nil
	case user.FieldLockedManual:
		m.ResetLockedManual()
		return nil
	case user.FieldNotify:
		m.ResetNotify()
		return nil
	case user.FieldNotifyTime:
		m.ResetNotifyTime()
		return nil
	case user.FieldNotifyLastTime:
		m.ResetNotifyLastTime()
		return nil
	case user.FieldStorePrivatKey:
		m.ResetStorePrivatKey()
		return nil
	case user.FieldEnableLogging:
		m.ResetEnableLogging()
		return nil
	case user.FieldRegistered:
		m.ResetRegistered()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.balance != nil {
		edges = append(edges, user.EdgeBalance)
	}
	if m.address_book != nil {
		edges = append(edges, user.EdgeAddressBook)
	}
	if m.state != nil {
		edges = append(edges, user.EdgeState)
	}
	if m.rewards_data != nil {
		edges = append(edges, user.EdgeRewardsData)
	}
	if m._PrivateKey != nil {
		edges = append(edges, user.EdgePrivateKey)
	}
	if m.transfers != nil {
		edges = append(edges, user.EdgeTransfers)
	}
	if m.delegates != nil {
		edges = append(edges, user.EdgeDelegates)
	}
	if m.undelegates != nil {
		edges = append(edges, user.EdgeUndelegates)
	}
	if m.swaps != nil {
		edges = append(edges, user.EdgeSwaps)
	}
	if m.invoices != nil {
		edges = append(edges, user.EdgeInvoices)
	}
	if m.recentInvoices != nil {
		edges = append(edges, user.EdgeRecentInvoices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBalance:
		if id := m.balance; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAddressBook:
		ids := make([]ent.Value, 0, len(m.address_book))
		for id := range m.address_book {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRewardsData:
		ids := make([]ent.Value, 0, len(m.rewards_data))
		for id := range m.rewards_data {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrivateKey:
		if id := m._PrivateKey; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTransfers:
		ids := make([]ent.Value, 0, len(m.transfers))
		for id := range m.transfers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDelegates:
		ids := make([]ent.Value, 0, len(m.delegates))
		for id := range m.delegates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUndelegates:
		ids := make([]ent.Value, 0, len(m.undelegates))
		for id := range m.undelegates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSwaps:
		ids := make([]ent.Value, 0, len(m.swaps))
		for id := range m.swaps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.invoices))
		for id := range m.invoices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecentInvoices:
		ids := make([]ent.Value, 0, len(m.recentInvoices))
		for id := range m.recentInvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedaddress_book != nil {
		edges = append(edges, user.EdgeAddressBook)
	}
	if m.removedrewards_data != nil {
		edges = append(edges, user.EdgeRewardsData)
	}
	if m.removedtransfers != nil {
		edges = append(edges, user.EdgeTransfers)
	}
	if m.removeddelegates != nil {
		edges = append(edges, user.EdgeDelegates)
	}
	if m.removedundelegates != nil {
		edges = append(edges, user.EdgeUndelegates)
	}
	if m.removedswaps != nil {
		edges = append(edges, user.EdgeSwaps)
	}
	if m.removedinvoices != nil {
		edges = append(edges, user.EdgeInvoices)
	}
	if m.removedrecentInvoices != nil {
		edges = append(edges, user.EdgeRecentInvoices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAddressBook:
		ids := make([]ent.Value, 0, len(m.removedaddress_book))
		for id := range m.removedaddress_book {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRewardsData:
		ids := make([]ent.Value, 0, len(m.removedrewards_data))
		for id := range m.removedrewards_data {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTransfers:
		ids := make([]ent.Value, 0, len(m.removedtransfers))
		for id := range m.removedtransfers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDelegates:
		ids := make([]ent.Value, 0, len(m.removeddelegates))
		for id := range m.removeddelegates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUndelegates:
		ids := make([]ent.Value, 0, len(m.removedundelegates))
		for id := range m.removedundelegates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSwaps:
		ids := make([]ent.Value, 0, len(m.removedswaps))
		for id := range m.removedswaps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvoices:
		ids := make([]ent.Value, 0, len(m.removedinvoices))
		for id := range m.removedinvoices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecentInvoices:
		ids := make([]ent.Value, 0, len(m.removedrecentInvoices))
		for id := range m.removedrecentInvoices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedbalance {
		edges = append(edges, user.EdgeBalance)
	}
	if m.clearedaddress_book {
		edges = append(edges, user.EdgeAddressBook)
	}
	if m.clearedstate {
		edges = append(edges, user.EdgeState)
	}
	if m.clearedrewards_data {
		edges = append(edges, user.EdgeRewardsData)
	}
	if m.cleared_PrivateKey {
		edges = append(edges, user.EdgePrivateKey)
	}
	if m.clearedtransfers {
		edges = append(edges, user.EdgeTransfers)
	}
	if m.cleareddelegates {
		edges = append(edges, user.EdgeDelegates)
	}
	if m.clearedundelegates {
		edges = append(edges, user.EdgeUndelegates)
	}
	if m.clearedswaps {
		edges = append(edges, user.EdgeSwaps)
	}
	if m.clearedinvoices {
		edges = append(edges, user.EdgeInvoices)
	}
	if m.clearedrecentInvoices {
		edges = append(edges, user.EdgeRecentInvoices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBalance:
		return m.clearedbalance
	case user.EdgeAddressBook:
		return m.clearedaddress_book
	case user.EdgeState:
		return m.clearedstate
	case user.EdgeRewardsData:
		return m.clearedrewards_data
	case user.EdgePrivateKey:
		return m.cleared_PrivateKey
	case user.EdgeTransfers:
		return m.clearedtransfers
	case user.EdgeDelegates:
		return m.cleareddelegates
	case user.EdgeUndelegates:
		return m.clearedundelegates
	case user.EdgeSwaps:
		return m.clearedswaps
	case user.EdgeInvoices:
		return m.clearedinvoices
	case user.EdgeRecentInvoices:
		return m.clearedrecentInvoices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeBalance:
		m.ClearBalance()
		return nil
	case user.EdgeState:
		m.ClearState()
		return nil
	case user.EdgePrivateKey:
		m.ClearPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBalance:
		m.ResetBalance()
		return nil
	case user.EdgeAddressBook:
		m.ResetAddressBook()
		return nil
	case user.EdgeState:
		m.ResetState()
		return nil
	case user.EdgeRewardsData:
		m.ResetRewardsData()
		return nil
	case user.EdgePrivateKey:
		m.ResetPrivateKey()
		return nil
	case user.EdgeTransfers:
		m.ResetTransfers()
		return nil
	case user.EdgeDelegates:
		m.ResetDelegates()
		return nil
	case user.EdgeUndelegates:
		m.ResetUndelegates()
		return nil
	case user.EdgeSwaps:
		m.ResetSwaps()
		return nil
	case user.EdgeInvoices:
		m.ResetInvoices()
		return nil
	case user.EdgeRecentInvoices:
		m.ResetRecentInvoices()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserStateMutation represents an operation that mutates the UserState nodes in the graph.
type UserStateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	state         *string
	data          *[]byte
	clearedFields map[string]struct{}
	owner         *int64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*UserState, error)
	predicates    []predicate.UserState
}

var _ ent.Mutation = (*UserStateMutation)(nil)

// userstateOption allows management of the mutation configuration using functional options.
type userstateOption func(*UserStateMutation)

// newUserStateMutation creates new mutation for the UserState entity.
func newUserStateMutation(c config, op Op, opts ...userstateOption) *UserStateMutation {
	m := &UserStateMutation{
		config:        c,
		op:            op,
		typ:           TypeUserState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserStateID sets the ID field of the mutation.
func withUserStateID(id int) userstateOption {
	return func(m *UserStateMutation) {
		var (
			err   error
			once  sync.Once
			value *UserState
		)
		m.oldValue = func(ctx context.Context) (*UserState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserState sets the old UserState of the mutation.
func withUserState(node *UserState) userstateOption {
	return func(m *UserStateMutation) {
		m.oldValue = func(context.Context) (*UserState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserStateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserStateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetState sets the "state" field.
func (m *UserStateMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *UserStateMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the UserState entity.
// If the UserState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStateMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *UserStateMutation) ResetState() {
	m.state = nil
}

// SetData sets the "data" field.
func (m *UserStateMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *UserStateMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the UserState entity.
// If the UserState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserStateMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *UserStateMutation) ClearData() {
	m.data = nil
	m.clearedFields[userstate.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *UserStateMutation) DataCleared() bool {
	_, ok := m.clearedFields[userstate.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *UserStateMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, userstate.FieldData)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *UserStateMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *UserStateMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *UserStateMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UserStateMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UserStateMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UserStateMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UserStateMutation builder.
func (m *UserStateMutation) Where(ps ...predicate.UserState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserState).
func (m *UserStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserStateMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.state != nil {
		fields = append(fields, userstate.FieldState)
	}
	if m.data != nil {
		fields = append(fields, userstate.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userstate.FieldState:
		return m.State()
	case userstate.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userstate.FieldState:
		return m.OldState(ctx)
	case userstate.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown UserState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userstate.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case userstate.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown UserState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserStateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userstate.FieldData) {
		fields = append(fields, userstate.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserStateMutation) ClearField(name string) error {
	switch name {
	case userstate.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown UserState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserStateMutation) ResetField(name string) error {
	switch name {
	case userstate.FieldState:
		m.ResetState()
		return nil
	case userstate.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown UserState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, userstate.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserStateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userstate.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, userstate.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserStateMutation) EdgeCleared(name string) bool {
	switch name {
	case userstate.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserStateMutation) ClearEdge(name string) error {
	switch name {
	case userstate.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown UserState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserStateMutation) ResetEdge(name string) error {
	switch name {
	case userstate.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown UserState edge %s", name)
}

// ValidatorsMutation represents an operation that mutates the Validators nodes in the graph.
type ValidatorsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	address       *string
	name          *string
	fee           *int8
	addfee        *int8
	delegators    *int64
	adddelegators *int64
	active        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Validators, error)
	predicates    []predicate.Validators
}

var _ ent.Mutation = (*ValidatorsMutation)(nil)

// validatorsOption allows management of the mutation configuration using functional options.
type validatorsOption func(*ValidatorsMutation)

// newValidatorsMutation creates new mutation for the Validators entity.
func newValidatorsMutation(c config, op Op, opts ...validatorsOption) *ValidatorsMutation {
	m := &ValidatorsMutation{
		config:        c,
		op:            op,
		typ:           TypeValidators,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withValidatorsID sets the ID field of the mutation.
func withValidatorsID(id int) validatorsOption {
	return func(m *ValidatorsMutation) {
		var (
			err   error
			once  sync.Once
			value *Validators
		)
		m.oldValue = func(ctx context.Context) (*Validators, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Validators.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withValidators sets the old Validators of the mutation.
func withValidators(node *Validators) validatorsOption {
	return func(m *ValidatorsMutation) {
		m.oldValue = func(context.Context) (*Validators, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ValidatorsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ValidatorsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ValidatorsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ValidatorsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Validators.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *ValidatorsMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ValidatorsMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Validators entity.
// If the Validators object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidatorsMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *ValidatorsMutation) ResetAddress() {
	m.address = nil
}

// SetName sets the "name" field.
func (m *ValidatorsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ValidatorsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Validators entity.
// If the Validators object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidatorsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ValidatorsMutation) ClearName() {
	m.name = nil
	m.clearedFields[validators.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ValidatorsMutation) NameCleared() bool {
	_, ok := m.clearedFields[validators.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ValidatorsMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, validators.FieldName)
}

// SetFee sets the "fee" field.
func (m *ValidatorsMutation) SetFee(i int8) {
	m.fee = &i
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *ValidatorsMutation) Fee() (r int8, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Validators entity.
// If the Validators object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidatorsMutation) OldFee(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds i to the "fee" field.
func (m *ValidatorsMutation) AddFee(i int8) {
	if m.addfee != nil {
		*m.addfee += i
	} else {
		m.addfee = &i
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *ValidatorsMutation) AddedFee() (r int8, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *ValidatorsMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[validators.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *ValidatorsMutation) FeeCleared() bool {
	_, ok := m.clearedFields[validators.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *ValidatorsMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, validators.FieldFee)
}

// SetDelegators sets the "delegators" field.
func (m *ValidatorsMutation) SetDelegators(i int64) {
	m.delegators = &i
	m.adddelegators = nil
}

// Delegators returns the value of the "delegators" field in the mutation.
func (m *ValidatorsMutation) Delegators() (r int64, exists bool) {
	v := m.delegators
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegators returns the old "delegators" field's value of the Validators entity.
// If the Validators object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidatorsMutation) OldDelegators(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelegators is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelegators requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegators: %w", err)
	}
	return oldValue.Delegators, nil
}

// AddDelegators adds i to the "delegators" field.
func (m *ValidatorsMutation) AddDelegators(i int64) {
	if m.adddelegators != nil {
		*m.adddelegators += i
	} else {
		m.adddelegators = &i
	}
}

// AddedDelegators returns the value that was added to the "delegators" field in this mutation.
func (m *ValidatorsMutation) AddedDelegators() (r int64, exists bool) {
	v := m.adddelegators
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelegators clears the value of the "delegators" field.
func (m *ValidatorsMutation) ClearDelegators() {
	m.delegators = nil
	m.adddelegators = nil
	m.clearedFields[validators.FieldDelegators] = struct{}{}
}

// DelegatorsCleared returns if the "delegators" field was cleared in this mutation.
func (m *ValidatorsMutation) DelegatorsCleared() bool {
	_, ok := m.clearedFields[validators.FieldDelegators]
	return ok
}

// ResetDelegators resets all changes to the "delegators" field.
func (m *ValidatorsMutation) ResetDelegators() {
	m.delegators = nil
	m.adddelegators = nil
	delete(m.clearedFields, validators.FieldDelegators)
}

// SetActive sets the "active" field.
func (m *ValidatorsMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ValidatorsMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Validators entity.
// If the Validators object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidatorsMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ClearActive clears the value of the "active" field.
func (m *ValidatorsMutation) ClearActive() {
	m.active = nil
	m.clearedFields[validators.FieldActive] = struct{}{}
}

// ActiveCleared returns if the "active" field was cleared in this mutation.
func (m *ValidatorsMutation) ActiveCleared() bool {
	_, ok := m.clearedFields[validators.FieldActive]
	return ok
}

// ResetActive resets all changes to the "active" field.
func (m *ValidatorsMutation) ResetActive() {
	m.active = nil
	delete(m.clearedFields, validators.FieldActive)
}

// Where appends a list predicates to the ValidatorsMutation builder.
func (m *ValidatorsMutation) Where(ps ...predicate.Validators) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ValidatorsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ValidatorsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Validators, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ValidatorsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ValidatorsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Validators).
func (m *ValidatorsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ValidatorsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.address != nil {
		fields = append(fields, validators.FieldAddress)
	}
	if m.name != nil {
		fields = append(fields, validators.FieldName)
	}
	if m.fee != nil {
		fields = append(fields, validators.FieldFee)
	}
	if m.delegators != nil {
		fields = append(fields, validators.FieldDelegators)
	}
	if m.active != nil {
		fields = append(fields, validators.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ValidatorsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case validators.FieldAddress:
		return m.Address()
	case validators.FieldName:
		return m.Name()
	case validators.FieldFee:
		return m.Fee()
	case validators.FieldDelegators:
		return m.Delegators()
	case validators.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ValidatorsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case validators.FieldAddress:
		return m.OldAddress(ctx)
	case validators.FieldName:
		return m.OldName(ctx)
	case validators.FieldFee:
		return m.OldFee(ctx)
	case validators.FieldDelegators:
		return m.OldDelegators(ctx)
	case validators.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Validators field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValidatorsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case validators.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case validators.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case validators.FieldFee:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case validators.FieldDelegators:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegators(v)
		return nil
	case validators.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Validators field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ValidatorsMutation) AddedFields() []string {
	var fields []string
	if m.addfee != nil {
		fields = append(fields, validators.FieldFee)
	}
	if m.adddelegators != nil {
		fields = append(fields, validators.FieldDelegators)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ValidatorsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case validators.FieldFee:
		return m.AddedFee()
	case validators.FieldDelegators:
		return m.AddedDelegators()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValidatorsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case validators.FieldFee:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case validators.FieldDelegators:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelegators(v)
		return nil
	}
	return fmt.Errorf("unknown Validators numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ValidatorsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(validators.FieldName) {
		fields = append(fields, validators.FieldName)
	}
	if m.FieldCleared(validators.FieldFee) {
		fields = append(fields, validators.FieldFee)
	}
	if m.FieldCleared(validators.FieldDelegators) {
		fields = append(fields, validators.FieldDelegators)
	}
	if m.FieldCleared(validators.FieldActive) {
		fields = append(fields, validators.FieldActive)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ValidatorsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ValidatorsMutation) ClearField(name string) error {
	switch name {
	case validators.FieldName:
		m.ClearName()
		return nil
	case validators.FieldFee:
		m.ClearFee()
		return nil
	case validators.FieldDelegators:
		m.ClearDelegators()
		return nil
	case validators.FieldActive:
		m.ClearActive()
		return nil
	}
	return fmt.Errorf("unknown Validators nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ValidatorsMutation) ResetField(name string) error {
	switch name {
	case validators.FieldAddress:
		m.ResetAddress()
		return nil
	case validators.FieldName:
		m.ResetName()
		return nil
	case validators.FieldFee:
		m.ResetFee()
		return nil
	case validators.FieldDelegators:
		m.ResetDelegators()
		return nil
	case validators.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Validators field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ValidatorsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ValidatorsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ValidatorsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ValidatorsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ValidatorsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ValidatorsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ValidatorsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Validators unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ValidatorsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Validators edge %s", name)
}
